<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>折返的Liung</title><link href="http://liung.github.io/" rel="alternate"></link><link href="http://liung.github.io/feeds%5Cliung.atom.xml" rel="self"></link><id>http://liung.github.io/</id><updated>2014-10-16T13:54:19+08:00</updated><entry><title>APM-Windows7上的MAVProxy使用</title><link href="http://liung.github.io/blog/apm/2014-10-16-APM-Windows7%E4%B8%8A%E7%9A%84MAVProxy%E4%BD%BF%E7%94%A8.html" rel="alternate"></link><updated>2014-10-16T13:54:19+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-10-16:blog/apm/2014-10-16-APM-Windows7上的MAVProxy使用.html</id><summary type="html">&lt;h3&gt;简介&lt;/h3&gt;
&lt;p&gt;本说明取自于Ben Dellar在DIY Drones上的一篇&lt;a href="http://diydrones.com/profiles/blogs/step-by-step-guide-to-mavproxy-on-windows-7-live-forward-your-uav?xg_source=activity"&gt;优秀的指导手册&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MAVProxy是一款强大的地面站软件，它极大的扩充了GUI界面的地面站。比如Mission Planner，APM Planner等。驱动我探索MAVProxy的最大动力在于，它对通过网络的UDP协议获取到的UAV信息和不同设备上的多种地面站软件的交互具有强大的兼容性。例如，你可以在笔记本上运行你的地面站软件，并通过天线或者wifi和手机/平板连接，从而可以在固定的天线转向之前轻松重新定位发送信号（you can run a ground station on a laptop next to your antenna and forward via wifi to a smartphone/tablet which lets you easily relocate to launch into wind before heading back to your fixed antenna.我也不是很明白 ：&amp;gt;）。我也曾经在一次长距离飞行中将遥测数据通过网络（4G VPN）发送给几千米之外充当观测员的朋友，这样，他就可以实时监测整个飞行，从而随时可以确定飞行器的位置信息。&lt;/p&gt;
&lt;p&gt;本手册将指导你如何成功设置MAVProxy从而可以通过命令行与网络界面通信。当然，也有许多其他方法可以让它运行，并且，为了能够使用一些高级方法，可能还需要其他的安装包，具体信息请看官方文档：&lt;a href="http://tridge.github.io/MAVProxy/"&gt;http://tridge.github.io/MAVProxy/&lt;/a&gt;。免责声明，所有信息归Andrew Tridgell及MAVProxy和这里用到的其他软件开发者所有。&lt;/p&gt;
&lt;p&gt;&lt;img alt="img0" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2014/05/Mavproxy_usage.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Step 1： 检查是否能够连接你的UAV&lt;/h3&gt;
&lt;p&gt;在开始任何事情之前请确保你的飞行器和地面站连接正常。检查连接到你的电脑上的端口及波特率（后面需要这些信息）。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Step 2：安装Python&lt;/h3&gt;
&lt;p&gt;下载并安装&lt;a href="https://www.python.org/download/releases/2.7/"&gt;Python2.7-WindowsX86 MSI&lt;/a&gt;，不需要关心OS/CPU类型。安装并采用默认安装位置：C:\Python27\&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Step 3：安装Pyserial&lt;/h3&gt;
&lt;p&gt;下载并安装&lt;a href="https://pypi.python.org/pypi/pyserial/2.7"&gt;Pyserial 2.7 – Win32 for Python 2.x (2.4…2.7) &lt;/a&gt;， 使用默认安装位置：&lt;strong&gt;C:\Python27\ directory&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Step 4：安装并设置MAVProxy&lt;/h3&gt;
&lt;p&gt;下载最新版的&lt;a href="https://pypi.python.org/pypi/MAVProxy"&gt;MAVProxy&lt;/a&gt; .tar.gz 文件（如果没有合适的解压缩工具，请安装&lt;a href="http://www.rarlab.com/download.htm"&gt;WinRAR&lt;/a&gt;）到*&lt;em&gt;C:\Python27*&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;解压完成之后就会出现&lt;strong&gt;C:\Python27\MAVProxy-1.3.3\MAVProxy &lt;/strong&gt;目录和&lt;strong&gt;mavproxy.py&lt;/strong&gt;文件&lt;/p&gt;
&lt;p&gt;右击&lt;strong&gt;mavproxy.py&lt;/strong&gt;文件选择IDLE打开。在文件第20行&lt;code&gt;sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), ‘..’))&lt;/code&gt;去掉前面的#，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="img1" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2014/05/Mavproxyedit.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Step 5：安装pymavlink&lt;/h3&gt;
&lt;p&gt;下载最新版&lt;a href="https://pypi.python.org/pypi/pymavlink"&gt;pymavlink&lt;/a&gt;，并解压到&lt;strong&gt;C:\Python27\MAVProxy-1.3.3\MAVProxy&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这将会在上面的目录中出现一个类似“pymavlink-1.1.29”的文件夹，将文件夹改名为pymavlink。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Step 6：准备运行&lt;/h3&gt;
&lt;p&gt;检查你的无线模块是否通过USB连到电脑上，飞行器模块和APM是否上电，确保所有地面站软件都已经关闭。&lt;/p&gt;
&lt;p&gt;打开命令终端窗口（start-&amp;gt;cmd,then press enter），输入&lt;code&gt;cd “C:\Python27\MAVProxy-1.3.3\MAVProxy”&lt;/code&gt;并按回车。命令窗口将会切到该目录下。&lt;/p&gt;
&lt;p&gt;然后输入&lt;code&gt;mavproxy.py –master=”com14″ –baudrate 57600&lt;/code&gt;（替换成你的本地连接端口和波特率），按回车。&lt;/p&gt;
&lt;p&gt;如果一切正常，MAVProxy就会启动，并出现一些基本的飞行数据，如模式及当前航点。偶尔一些数据可能会出现干扰并显示出一些奇怪的字符，但这并不影响总体的可靠性和性能。&lt;/p&gt;
&lt;p&gt;&lt;img alt="img3" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2014/05/mavproxy_running.png" /&gt;&lt;/p&gt;
&lt;p&gt;命令窗口输入&lt;code&gt;mode FBWA&lt;/code&gt;，按回车。就会看到MAVLink报告模式改变并通知你的飞行器将切换到该模式下。&lt;/p&gt;
&lt;p&gt;如果你想在命令行测试更多的命令，可以在&lt;a href="http://tridge.github.io/MAVProxy/"&gt;这里&lt;/a&gt;找到MAVLink的所有命令。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Step 7：网络收发&lt;/h3&gt;
&lt;p&gt;为了和PC上的本地程序通过网络收发MAV数据，我们可以简单的在在命令启动MAVProxy时添加额外的参数。&lt;/p&gt;
&lt;p&gt;为了和地面站软件连接（如Mission Planner），可以使用下述命令启动MAVProxy：&lt;code&gt;mavproxy.py –master=”com14″ –baudrate 57600 –out 127.0.0.1:14550&lt;/code&gt;并按回车。&lt;/p&gt;
&lt;p&gt;然后打开Mission Planner，选择UDP，点击连接。当点击完默认弹出的端口号（14550）提示OK后，就能看到Mission Planner开始下载参数并连接到你的UAV上。&lt;/p&gt;
&lt;p&gt;最后，你还可以添加任何发送遥测数据流到任何电脑的地面站软件的IP地址信息。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在本地网络/wifi环境中，需要确保本地PC上没有防火墙阻止向地面站的输入数据流的发送。&lt;/li&gt;
&lt;li&gt;在mavproxy.py命令的后面添加： –out IP_ADDRESS:14550。你还可以添加许多单独的-out参数，这取决于你运行了多少地面站软件。&lt;/li&gt;
&lt;li&gt;设置每个地面站在端口14550监听UDP包&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h3&gt;Step 8: 使用批处理文件简单启动&lt;/h3&gt;
&lt;p&gt;为了简化MAVProxy的启动，我（原作者）已经写了一个简单的5行批处理文件：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://api.ning.com/files/LAl787uzrCCKik-3pTnOKtXuYtVXVMkpLenY6ZJqdXwGtQI-7IYZxf*Lqb*X*iWsM48fW6B0IXNiJP24esqUxLduGtyOQbKY/StartMavproxy.bat"&gt;Mavproxy Startup Batch File&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你可以编辑参数为你的本地端口，波特率及需要传送数据的IP地址等。&lt;/p&gt;
&lt;p&gt;简单的保存并双击就可以启动MAVProxy（假设你已经遵循了上述的操作）&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;链接&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/mavproxy-on-windows-7/"&gt;APM官网原文链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html"&gt;APM开发人员参考手册目录列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;(over)&lt;/em&gt;&lt;/p&gt;</summary><category term="APM"></category><category term="飞控板"></category><category term="硬件"></category></entry><entry><title>APM-回放功能测试</title><link href="http://liung.github.io/blog/apm/2014-10-15-APM-%E5%9B%9E%E6%94%BE%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95.html" rel="alternate"></link><updated>2014-10-15T18:44:26+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-10-15:blog/apm/2014-10-15-APM-回放功能测试.html</id><summary type="html">&lt;h3&gt;简介&lt;/h3&gt;
&lt;p&gt;回放功能是用来处理dataflash日志文件的一套程序，并通过最近的主代码展示一系列基于真实数据的模拟结果。它可以用来重现产生bug的准确情形，或在同样的条件下测试改变EKF参数的影响。回放功能仅仅运行于Liunx/Ubuntu平台，且仅适用来自于高速CPU诸如PX4/Pixhawk运行2014年5月之后的ArduCopter/ArduPlane/ArduRover（例如AC3.2-dev或更高版本）所产生的dataflash日志文件。&lt;/p&gt;
&lt;p&gt;&lt;img alt="img0" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2014/05/Replay_EKFVsINAV.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;回放功能所需要的Dataflash日志信息&lt;/h3&gt;
&lt;p&gt;为了能够使用回放功能，下面的dataflash信息必须被启用：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AHRS2, BARO, EKF1, EKF2, EKF3, EKF4, GPS, IMU, IMU2, MAG, MAG2&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;编译回放模块&lt;/h3&gt;
&lt;p&gt;在你的Liunx上或Ubuntu虚拟机上：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ardupilot&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Tools&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Replay&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;linux&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述操作将会生成一个&lt;code&gt;/tmp/Replay.build/Replay.elf&lt;/code&gt;文件&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;使用回放功能&lt;/h3&gt;
&lt;p&gt;首先，将你需要分析的dataflash日志文件放入&lt;code&gt;../ardupilot/Tools/Replay&lt;/code&gt;目录。&lt;/p&gt;
&lt;p&gt;显示回放帮助：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Replay&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Replay&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;elf&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过Replay运行日志，生成图片和EKF数据文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Replay&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Replay&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;elf&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r400&lt;/span&gt; &lt;span class="n"&gt;MyLogFile&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BIN&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：参数&lt;code&gt;-r400&lt;/code&gt;是针对ArduCopter的主循环运行频率，对于ArduPlane和Rover自动忽略或替换为&lt;code&gt;-r50&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上述操作将会产生六个输出文件：plot.dat, plot2.dat, EKF1.dat, EKF2.dat, EKF3.dat, EKF4.dat&lt;/p&gt;
&lt;p&gt;查看原始文件用来了解哪些有用的数值需要被绘制：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;less&lt;/span&gt; &lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;  &lt;span class="c1"&gt;//可以用其它六个文件的任何一个文件来代替 plot.dat&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="img1" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2014/05/Replay_PlotDatColumns-300x150.png" /&gt;&lt;/p&gt;
&lt;p&gt;可以使用相对简单的plotit.sh脚本来绘制数据。下面命令用来比较由EKF计算的高度与较早的使用惯性导航计算的高度和实际飞行高度。&lt;/p&gt;
&lt;p&gt;&lt;img alt="img1" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2014/05/Replay_EKFInavFlightAlt.png" /&gt;&lt;/p&gt;
&lt;p&gt;也可以使用更复杂的mavgraph.py来绘制数据：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;mavgraph&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt; &lt;span class="n"&gt;MyLogFile&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BIN&lt;/span&gt; &lt;span class="n"&gt;EKF1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PN&lt;/span&gt; &lt;span class="n"&gt;NTUN&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PosX&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mf"&gt;0.01&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个例子用来将EKF估算的相对家的南北位置与较早的惯性导航估算的位置做比较。结果请看本页的第一张图片。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;链接&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/testing-with-replay/"&gt;APM官网原文链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html"&gt;APM开发人员参考手册目录列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;(over)&lt;/em&gt;&lt;/p&gt;</summary><category term="APM"></category><category term="飞控板"></category><category term="硬件"></category></entry><entry><title>APM-Linux上SITL仿真设置</title><link href="http://liung.github.io/blog/apm/2014-10-14-APM-Linux%E4%B8%8ASITL%E4%BB%BF%E7%9C%9F%E8%AE%BE%E7%BD%AE.html" rel="alternate"></link><updated>2014-10-15T14:06:42+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-10-15:blog/apm/2014-10-14-APM-Linux上SITL仿真设置.html</id><summary type="html">&lt;h3&gt;简介&lt;/h3&gt;
&lt;p&gt;SITL（software in the loop）仿真可以让你在没有任何硬件的情况下运行ArduPlane，Copter或者Rover。它使用通用的C++编译器来完成autopilot的代码编译工作，从而可以让你从运行过程中不需要任何硬件就能完成代码的测试。&lt;/p&gt;
&lt;p&gt;本页面详细说明了如何在Linux平台上设置SITL。文中使用的相关命令在 &lt;strong&gt;Ubuntu 12.10&lt;/strong&gt; 和 &lt;strong&gt;Ubuntu 13.04&lt;/strong&gt;  平台上测试通过。&lt;/p&gt;
&lt;p&gt;&lt;img alt="img0" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/04/SITL_Linux.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;相关细节&lt;/h3&gt;
&lt;p&gt;HITL（Hardware In The Loop）模拟对于APM代码测试工作相当有用，但是对于某些任务存在一些限制。这些限制包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能运行所有的autopilot代码，因为当硬件放置在桌面上时，底层驱动不能兼容所有的飞行测试输入量。&lt;/li&gt;
&lt;li&gt;不能使用一系列对正常C++调试非常有用的高级编程工具（例如调试器和内存监视器）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内建有ArduPilot的SITL克服了上述限制，它仍然运行相同的代码，但是它是作为PC上的本地可执行程序，并且使用了一些C++技巧，在注册层来模拟APM飞控板的硬件。所以，这些底层的硬件驱动（例如ADC， 陀螺仪，加速度计和GPS）就像真实飞行环境一样正常运行。&lt;/p&gt;
&lt;p&gt;APM的SITL环境在如下系统中开发并测试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows： Windows 7&lt;/li&gt;
&lt;li&gt;Linux： Ubuntu 13.04 或 之后版本&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;关于虚拟机&lt;/h3&gt;
&lt;p&gt;如果你尝试在虚拟机上运行SITL，你可能会发现定时器非常糟糕以至于很难飞行。具体表现为飞行非常不稳定或者经常撞机。那么，你可以通过以下方法来改善这种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置虚拟机使用尽可能多的CPU数量&lt;/li&gt;
&lt;li&gt;不使用ardupilot中EKF（旧的DCM代码对于差的传感器定时处理相对灵活）。设置方法：在mavproxy终端键入“&lt;code&gt;param set AHRS_EKF_USE 0&lt;/code&gt;”&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;安装步骤&lt;/h3&gt;
&lt;p&gt;请遵循以下步骤&lt;/p&gt;
&lt;h4&gt;Step 1： 下载ardupilot&lt;/h4&gt;
&lt;p&gt;如果没有ardupilot的git库本地备份，请打开终端并运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/diydrones/ardupilot.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Step 2： JSBSim&lt;/h4&gt;
&lt;p&gt;如果你想要运行固定翼模拟器，那么你就需要JSBSim包。在同一目录下（home目录）运行下面命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/tridge/jsbsim.git&lt;/span&gt;
&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;libtool&lt;/span&gt; &lt;span class="n"&gt;automake&lt;/span&gt; &lt;span class="n"&gt;autoconf&lt;/span&gt; &lt;span class="n"&gt;libexpat1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Step 3： 安装所需包&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;python&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;matplotlib&lt;/span&gt; &lt;span class="n"&gt;python&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;serial&lt;/span&gt; &lt;span class="n"&gt;python&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;wxgtk2&lt;/span&gt;&lt;span class="mf"&gt;.8&lt;/span&gt; &lt;span class="n"&gt;python&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;lxml&lt;/span&gt;
&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;python&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;scipy&lt;/span&gt; &lt;span class="n"&gt;python&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;opencv&lt;/span&gt; &lt;span class="n"&gt;ccache&lt;/span&gt; &lt;span class="n"&gt;gawk&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;python&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pip&lt;/span&gt;
&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;pymavlink&lt;/span&gt; &lt;span class="n"&gt;MAVProxy&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Step 4： 将目录添加到搜索路径&lt;/h4&gt;
&lt;p&gt;添加下面几行到home目录中“.bashrc”的文件尾部（注意文件名以&lt;strong&gt;.&lt;/strong&gt;开始）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;export&lt;/span&gt; &lt;span class="n"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;HOME&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ardupilot&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Tools&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;autotest&lt;/span&gt;
&lt;span class="n"&gt;export&lt;/span&gt; &lt;span class="n"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;HOME&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;MAVProxy&lt;/span&gt;
&lt;span class="n"&gt;export&lt;/span&gt; &lt;span class="n"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;HOME&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mavlink&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;pymavlink&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;examples&lt;/span&gt;
&lt;span class="n"&gt;export&lt;/span&gt; &lt;span class="n"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;HOME&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;jsbsim&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;
&lt;span class="n"&gt;export&lt;/span&gt; &lt;span class="n"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lib&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ccache&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;PATH&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后使用“&lt;strong&gt;.&lt;/strong&gt;”命令在终端重载路径文件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bashrc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Step 5： 编译JSBSim，运行如下命令&lt;/h4&gt;
&lt;p&gt;如果要运行SITL中的固定翼版本，那么你需要安装JSBSim。（Copter 和 Rover 不需要）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;jsbsim&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;autogen&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Step 6： 启动SITL模拟器&lt;/h4&gt;
&lt;p&gt;开始运行模拟器，首先需要将目录切换到对应飞行器目录。例如，对于固定翼需要将目录切换到ardupilot/ArduPlane。&lt;/p&gt;
&lt;p&gt;使用sim_vehicle.sh启动模拟器。第一次启动时需要加-w命令选项来清除之前的EEPROM数据，加载当前你的飞行器的正确默认参数，并使用“make configure”来生成配置文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;configure&lt;/span&gt;
&lt;span class="n"&gt;sim_vehicle&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当默认参数加载完成，就可以正常启动模拟器了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sim_vehicle&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;console&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;aircraft&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;sim_vehicle.sh有许多有用参数选项。请使用-h项查看可用的选项哦~&lt;/p&gt;
&lt;h4&gt;Step 7： 加载任务&lt;/h4&gt;
&lt;p&gt;让我们来开始加载测试任务吧~&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wp&lt;/span&gt; &lt;span class="n"&gt;load&lt;/span&gt; &lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Tools&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;autotest&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ArduPlane&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Missions&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;CMAC&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;toff&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个任务写入了绕我本地领域的一个飞行循环。现在开始起飞~在MAVProxy中运行“&lt;code&gt;auto&lt;/code&gt;”，你的虚拟飞行器现在开始起飞啦~啦~~哦~&lt;/p&gt;
&lt;h4&gt;Step 8： 学习MAVProxy&lt;/h4&gt;
&lt;p&gt;想要学习SITL之外的东西？那就开始学习使用MAVProxy吧。这个是&lt;a href="http://tridge.github.io/MAVProxy/"&gt;MAVProxy文档&lt;/a&gt;。飞行愉快哦~0-0.&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;链接&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/setting-up-sitl-on-linux/"&gt;APM官网原文链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html"&gt;APM开发人员参考手册目录列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;(over)&lt;/em&gt;&lt;/p&gt;&lt;script type= "text/javascript"&gt;
    if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
        var mathjaxscript = document.createElement('script');
        mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
        mathjaxscript.type = 'text/javascript';
        mathjaxscript.src = 'https:' == document.location.protocol
                ? 'https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'
                : 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
        mathjaxscript[(window.opera ? "innerHTML" : "text")] =
            "MathJax.Hub.Config({" +
            "    config: ['MMLorHTML.js']," +
            "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
            "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
            "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
            "    displayAlign: 'center'," +
            "    displayIndent: '0em'," +
            "    showMathMenu: true," +
            "    tex2jax: { " +
            "        inlineMath: [ ['$','$'] ], " +
            "        displayMath: [ ['$$','$$'] ]," +
            "        processEscapes: true," +
            "        preview: 'TeX'," +
            "    }, " +
            "    'HTML-CSS': { " +
            "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }" +
            "    } " +
            "}); ";
        (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
    }
&lt;/script&gt;
</summary><category term="APM"></category><category term="飞控板"></category><category term="硬件"></category></entry><entry><title>APM-Windows上SITL仿真设置</title><link href="http://liung.github.io/blog/apm/2014-10-14-APM-Windows%E4%B8%8ASITL%E4%BB%BF%E7%9C%9F%E8%AE%BE%E7%BD%AE.html" rel="alternate"></link><updated>2014-10-14T13:56:44+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-10-14:blog/apm/2014-10-14-APM-Windows上SITL仿真设置.html</id><summary type="html">&lt;h3&gt;简介&lt;/h3&gt;
&lt;p&gt;SITL（software in the loop）仿真可以让你在没有任何硬件的情况下运行ArduPlane，Copter或者Rover。它使用通用的C++编译器来完成autopilot的代码编译工作，从而可以让你从运行过程中不需要任何硬件就能完成代码的测试。&lt;/p&gt;
&lt;p&gt;本页面详细说明了如何在windows平台上设置SITL。文中使用的相关命令在装有&lt;strong&gt;VMware ver 5.0.2 build -1031769&lt;/strong&gt; 和 &lt;strong&gt;Ubuntu 12.10&lt;/strong&gt;的Windows8平台上测试通过。&lt;/p&gt;
&lt;p&gt;需要注意的是：在完成本页面操作请先将&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-获取源码.html"&gt;Ardupilot代码&lt;/a&gt;下载到你的电脑上，并且可以使用&lt;a href="http://liung.github.io/blog/apm/2014-09-06-APM-Windows平台上用Arduino编译ArduPilot.html"&gt;arduino&lt;/a&gt;或者&lt;a href="http://liung.github.io/blog/apm/2014-09-07-APM-Windows平台上用Make方法编译Pixhawk和PX4.html"&gt;Make方法&lt;/a&gt;编译。&lt;/p&gt;
&lt;p&gt;&lt;img alt="img1" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/12/Ubuntu_SITL_running_Copter.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Step #1 安装VMWare并创建Ubuntu虚拟机&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;下载并安装&lt;a href="https://my.vmware.com/web/vmware/free#desktop_end_user_computing/vmware_player/6_0"&gt;VMware&lt;/a&gt;（搜索VMware Player或者windows平台VMware Player Plus）&lt;/li&gt;
&lt;li&gt;下载&lt;a href="http://www.ubuntu.com/download/desktop/thank-you?release=latest&amp;amp;bits=32&amp;amp;distro=desktop&amp;amp;status=zeroc"&gt;Ubuntu ISO&lt;/a&gt;镜像文件&lt;/li&gt;
&lt;li&gt;开始运行VMware，选择 Player&amp;gt;File&amp;gt;New Virtual Machine，建立一个新虚拟机&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;填写用户全称，虚拟机的用户名和密码。当你登陆你的虚拟机时将会用到。&lt;/li&gt;
&lt;li&gt;命名你的虚拟机（例如 ArduCopter-SITL）&lt;/li&gt;
&lt;li&gt;设置硬盘空间-保持默认20GB的最大空间，并选择“分割虚拟硬盘为多文件”&lt;/li&gt;
&lt;li&gt;在“新虚拟机向导”的下一页面，电机“自定义硬件”按钮。&lt;/li&gt;
&lt;li&gt;在硬件栏设置内存：3GB，处理器：4，硬盘容量：20GB，网络适配器：NAT&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img alt="img2" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/12/Ubuntu_VMSettings_Hardware.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Step #2 初次运行VM&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、&lt;/strong&gt;双击启动刚刚创建的虚拟机&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、&lt;/strong&gt;当遇到任何像 “Cannot connect to the XXX device because no corresponding device is available on the host”的问题时点"No"&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、&lt;/strong&gt;在登陆界面输入密码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、&lt;/strong&gt;当提示升级时选择不升级&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、&lt;/strong&gt;打开火狐浏览器确保虚拟机能够连接网络&lt;/p&gt;
&lt;p&gt;&lt;img alt="img3" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/12/Ubuntu_TestNetworkWithFirefox-300x205.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、&lt;/strong&gt;双击右上角设置时钟，选择地图中你的位置，然后“设置时间”为“自动从网络获取”&lt;/p&gt;
&lt;p&gt;&lt;img alt="img4" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/12/Ubuntu_setTimezone-300x212.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、&lt;/strong&gt;设置终端窗口快捷方式：点击左上角的Home图标，键入“终端（terminal）”，然后将终端应用拖拽到左边的起始栏&lt;/p&gt;
&lt;p&gt;&lt;img alt="img5" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/12/Ubuntu_TerminalShortcut-1024x488.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Step #3 设置Windows和Ubuntu虚拟机的共享文件&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、&lt;/strong&gt;确保VM已经关闭电源：在绿色按钮的下拉菜单中选择“Power Off”（如果不是灰色）&lt;/p&gt;
&lt;p&gt;&lt;img alt="img6" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/12/Ubuntu_PowerOff-300x200.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、&lt;/strong&gt;在VMware虚拟机界面选择Player&amp;gt;Manage&amp;gt;Virtual Machine Settings ... &amp;gt; Options Tab&amp;gt;Shared Folders&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选中“Always enabled”，点击Add&lt;/li&gt;
&lt;li&gt;将“Host Path”设置导航到安装有ardupilot软件的文件夹位置&lt;/li&gt;
&lt;li&gt;选中“Enable this share”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="img7" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/12/Ubuntu_VMSettings_SetupSharedFolder.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、&lt;/strong&gt;启动VM，进入系统&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、&lt;/strong&gt;打开终端，键入“&lt;code&gt;ls/mnt/hgfs&lt;/code&gt;”，然后你应该能看到你刚刚设置共享的文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、&lt;/strong&gt;输入“&lt;code&gt;ln -s /mnt/hgfs/&amp;lt;foldername&amp;gt;&lt;/code&gt;”(&lt;foldername&gt;替换成上面你设置的共享文件名)，用以在主目录创建一个符号链接。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Step #4 在你的VM上安装所需模块&lt;/h3&gt;
&lt;p&gt;打开终端，然后输入下面命令：
&lt;code&gt;sudo apt-get update&lt;/code&gt; &amp;lt;--用来从软件中心升级一系列包&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo apt-get install &amp;lt;name&amp;gt;&lt;/code&gt;安装下列文件（回复'y'确保你有足够的剩余空间可以使用）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dos2unix&lt;/li&gt;
&lt;li&gt;python-wxgtk2.8&lt;/li&gt;
&lt;li&gt;python-matplotlib&lt;/li&gt;
&lt;li&gt;python-opencv&lt;/li&gt;
&lt;li&gt;python-pip&lt;/li&gt;
&lt;li&gt;g++&lt;/li&gt;
&lt;li&gt;g++-4.7&lt;/li&gt;
&lt;li&gt;gawk&lt;/li&gt;
&lt;li&gt;git&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ccache&lt;/p&gt;
&lt;p&gt;sudo pip install pymavlink
sudo pip install mavproxy&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你想运行ArduPlane，那么你还需要安装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;libexpat1-dev&lt;/li&gt;
&lt;li&gt;auto.conf&lt;/li&gt;
&lt;li&gt;libtool&lt;/li&gt;
&lt;li&gt;automake&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;Step #5 按照如下Linux说明&lt;/h3&gt;
&lt;p&gt;现在你已经有了Linux的VM虚拟机，你可以参照&lt;a href="http://liung.github.io/blog/apm/2014-10-14-APM-Linux上SITL仿真设置.html"&gt;Liunx平台软件仿真&lt;/a&gt;说明。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;连接Mission Planner&lt;/h3&gt;
&lt;p&gt;除了使用Mavproxy地面站外(使用Python写的地面站)，还可能要和Mission Planner链接，这就需要在启动命令后面添加上&lt;code&gt;--viewerip=xxx.x.x.x&lt;/code&gt;,也就是你电脑的IP地址，通过在cmd界面键入&lt;code&gt;ipconfig&lt;/code&gt;来查看你电脑的IP&lt;/p&gt;
&lt;p&gt;注意：你可能需要尝试图片中的各个IP地址，直到地面站可以正常通信为止&lt;/p&gt;
&lt;p&gt;&lt;img alt="img8" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/12/SITL_ipconfig.png" /&gt;&lt;/p&gt;
&lt;p&gt;那么，在Ubuntu虚拟机的终端就可以键入如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Tools&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;autotest&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;autotest&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArduCopter&lt;/span&gt; &lt;span class="n"&gt;fly&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArduCopter&lt;/span&gt; &lt;span class="n"&gt;logs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArduCopter&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;viewerip&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;192.168.184.1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来首先将Mission Planner的连接方式从“COM Port”改为“UDP”&lt;/p&gt;
&lt;p&gt;&lt;img alt="img9" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/12/SITL_connectWithMP.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;数据存储器（Dataflash）日志&lt;/h3&gt;
&lt;p&gt;当模拟开始后，以“ArduCopter.flashlog”或“CopterAVC.flashlog”命名的数据日志文件将会在“buildlogs”文件夹自动创建，该目录和ardupilot目录（包含有ArduCopter、ArduPlane和libraries目录的上层目录）处于同一级别。由于命名的不便，在打开Mission Planner之前，你需要先将这些文件改为以“.log”结尾。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;链接&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="dev.ardupilot.com/wiki/setting-up-sitl-on-windows/"&gt;APM官网原文链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html"&gt;APM开发人员参考手册目录列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;(over)&lt;/em&gt;&lt;/p&gt;</summary><category term="APM"></category><category term="飞控板"></category><category term="硬件"></category></entry><entry><title>APM-模拟仿真</title><link href="http://liung.github.io/blog/apm/2014-10-14-APM-%E6%A8%A1%E6%8B%9F%E4%BB%BF%E7%9C%9F.html" rel="alternate"></link><updated>2014-10-14T13:52:49+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-10-14:blog/apm/2014-10-14-APM-模拟仿真.html</id><summary type="html">&lt;p&gt;本页面描述了如何使用APM进行模拟仿真，它可以让我们安全的测试试验代码和一些设置。毕竟，撞毁模拟飞机可要比真实的飞机划算的多哦！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;硬件循环仿真（HITL）:&lt;/strong&gt;硬件仿真使用模拟器代替真实的飞行器和大气环境，该模拟器包含有高精度的飞行动力学模型和大气环境模型（模拟气流，突风等）。通过在飞行中采用APM飞控板，连接运行模拟器的电脑，来代替真实飞行器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件循环仿真（HITL）:&lt;/strong&gt;软件仿真额外的将APM飞控板虚拟化，如同硬件仿真中的飞行器和大气环境一样，它有利于原型快速开发，或者物理硬件（autopilots板或地面站）不可用或缺失时。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-10-14-APM-Linux上SITL仿真设置.html"&gt;Linux上SITL仿真设置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-10-14-APM-Windows上SITL仿真设置.html"&gt;Windows上SITL仿真设置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;日志回放：&lt;/strong&gt;你可以使用系统的“Replay”功能回放二进制dataflash日志文件，来查看ardupilot内部组件各个方面的输出特性。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;链接&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/simulation-2/"&gt;APM官网原文链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html"&gt;APM开发人员参考手册目录列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;(over)&lt;/em&gt;&lt;/p&gt;</summary><category term="APM"></category><category term="飞控板"></category><category term="硬件"></category></entry><entry><title>常用气动软件</title><link href="http://liung.github.io/blog/qi-dong/2014-09-17-%E5%B8%B8%E7%94%A8%E6%B0%94%E5%8A%A8%E8%BD%AF%E4%BB%B6.html" rel="alternate"></link><updated>2014-09-17T10:55:29+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-09-17:blog/qi-dong/2014-09-17-常用气动软件.html</id><summary type="html">&lt;h3&gt;XFoil&lt;/h3&gt;
&lt;p&gt;XFoil是一个为设计和分析亚音速飞机独立翼型编写的互动式的程序&lt;/p&gt;
&lt;p&gt;主页：&lt;a href="http://web.mit.edu/drela/Public/web/xfoil/"&gt;&lt;strong&gt;http://web.mit.edu/drela/Public/web/xfoil/&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Profili&lt;/h3&gt;
&lt;p&gt;Profili是一款用来帮助你进行飞机机翼设计和分析机翼的空气动力学的分析设计软件&lt;/p&gt;
&lt;h3&gt;AVL&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://web.mit.edu/drela/Public/web/avl/"&gt;AVL&lt;/a&gt;是MIT（麻省理工）用fortran开发的一个气动和飞行动力学分析程序。&lt;/p&gt;
&lt;p&gt;下面是它的一个官方说明：&lt;/p&gt;
&lt;p&gt;AVL is a program for the aerodynamic and flight-dynamic analysis of rigid aircraft 
of arbitrary configuration. It employs an extended &lt;strong&gt;vortex lattice model&lt;/strong&gt; for 
the lifting surfaces, together with a slender-body model for fuselages and nacelles. 
General nonlinear flight states can be specified. The flight dynamic analysis 
combines a &lt;strong&gt;full linearization of the aerodynamic model&lt;/strong&gt; about any flight state, 
together with specified mass properties.&lt;/p&gt;
&lt;h4&gt;扩展涡格模型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;气动组成&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;升力面&lt;/li&gt;
&lt;li&gt;细长体&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结构定义&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;以关键字描述几何外形的输入文件&lt;/li&gt;
&lt;li&gt;线性差值定义截面&lt;/li&gt;
&lt;li&gt;截面属性&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;翼型：NACA xxxx 或者来自翼型文件&lt;/li&gt;
&lt;li&gt;操纵面偏转&lt;/li&gt;
&lt;li&gt;抛物线形剖面极线，尺度放缩&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;整个表面或机身的缩放，平移，旋转操作&lt;/li&gt;
&lt;li&gt;整个表面或机身的重叠设置&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;离散化&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Uniform（归一化）&lt;/li&gt;
&lt;li&gt;Sine&lt;/li&gt;
&lt;li&gt;Cosine&lt;/li&gt;
&lt;li&gt;Blend（组合）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;控制舵面的偏转&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Via normal-vector tilting（通过倾斜法向量）&lt;/li&gt;
&lt;li&gt;前缘或后缘副翼&lt;/li&gt;
&lt;li&gt;Flaps independent of discretization（副翼的离散化）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通常的自由来流描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;$\alpha, \beta$， 来流角度&lt;/li&gt;
&lt;li&gt;p, q, r 飞行器旋转角速度分量&lt;/li&gt;
&lt;li&gt;亚音速的普朗特-葛劳涡（Prandtl-Glauert）压缩性修正&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;气动力和力矩输出&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;体轴和稳定轴系下的气动力或力矩&lt;/li&gt;
&lt;li&gt;包含有阻力特性分析的Trefftz-plane &lt;/li&gt;
&lt;li&gt;力和力矩导数，关于角度，旋转角速度，控制面等...&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;配平计算&lt;/h4&gt;
&lt;h4&gt;质量特性&lt;/h4&gt;
&lt;h4&gt;模态分析&lt;/h4&gt;
&lt;h4&gt;非定常流动&lt;/h4&gt;
&lt;p&gt;AVL对于非定常流动都假定为准定常流动，这意味着计算时忽略了非定常脱落涡流。而且，AVL还将飞机状态限定在一定的缩减频率范围内，如，无量纲的旋转角速度一般做如下限制：&lt;/p&gt;
&lt;p&gt;-0.10 &amp;lt; pb/2V &amp;lt; 0.10&lt;/p&gt;
&lt;p&gt;-0.03 &amp;lt; qc/2V &amp;lt; 0.03&lt;/p&gt;
&lt;p&gt;-0.25 &amp;lt; rb/2V &amp;lt; 0.25&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://web.mit.edu/drela/Public/web/avl/avl_doc.txt"&gt;帮助文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;AirFoil&lt;/h3&gt;
&lt;h3&gt;XFLR5&lt;/h3&gt;
&lt;p&gt;项目地址：&lt;a href="http://www.xflr5.cn/"&gt;&lt;strong&gt;http://www.xflr5.cn&lt;/strong&gt;/&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Tornado&lt;/h3&gt;
&lt;p&gt;用Matlab编写的基于涡格法的分析程序&lt;/p&gt;
&lt;h3&gt;QBlade&lt;/h3&gt;
&lt;p&gt;QBlade is a Blade Element Momentum Method (BEM) and Double Multiple Streamtube (DMS) Design and Simulation Software for Vertical- and Horizontal Axis Wind Turbines. It also includes tools to setup and simulate the internal blade structure and perform an aeroelastic analysis of a wind turbine rotor in turbulent inflow conditions through a coupling with FAST from NREL&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href="http://www.q-blade.org/"&gt;&lt;strong&gt;http://www.q-blade.org/&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Manticore Aerofoil Design&lt;/h3&gt;
&lt;p&gt;Aerofoil design software based on Panel2D from Aerospace, Mechanical &amp;amp; Mechatronic Engineering, University of Sydney with considerable enhancements.&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href="http://mdesign.sourceforge.net/"&gt;&lt;strong&gt;http://mdesign.sourceforge.net/&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Foils - model airfoil plotter&lt;/h3&gt;
&lt;p&gt;Draws accurately scaled model airfoil rib or foam cutting templates on any
printer in Windows 3.1 or later, or via clipboard to some drawing and CAD programs.&lt;/p&gt;
&lt;p&gt;主页地址：&lt;a href="http://foils.sourceforge.net/"&gt;&lt;strong&gt;http://foils.sourceforge.net/&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;script type= "text/javascript"&gt;
    if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
        var mathjaxscript = document.createElement('script');
        mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
        mathjaxscript.type = 'text/javascript';
        mathjaxscript.src = 'https:' == document.location.protocol
                ? 'https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'
                : 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
        mathjaxscript[(window.opera ? "innerHTML" : "text")] =
            "MathJax.Hub.Config({" +
            "    config: ['MMLorHTML.js']," +
            "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
            "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
            "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
            "    displayAlign: 'center'," +
            "    displayIndent: '0em'," +
            "    showMathMenu: true," +
            "    tex2jax: { " +
            "        inlineMath: [ ['$','$'] ], " +
            "        displayMath: [ ['$$','$$'] ]," +
            "        processEscapes: true," +
            "        preview: 'TeX'," +
            "    }, " +
            "    'HTML-CSS': { " +
            "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }" +
            "    } " +
            "}); ";
        (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
    }
&lt;/script&gt;
</summary><category term="气动"></category><category term="气动软件"></category></entry><entry><title>Numpy学习笔记</title><link href="http://liung.github.io/blog/python/2014-09-14-numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate"></link><updated>2014-09-14T12:49:44+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-09-14:blog/python/2014-09-14-numpy学习笔记.html</id><summary type="html">&lt;hr /&gt;
&lt;h3&gt;数组的方法&lt;/h3&gt;
&lt;h4&gt;数组转置和轴对换&lt;/h4&gt;
&lt;p&gt;转置（&lt;strong&gt;transpose&lt;/strong&gt;，或者通过&lt;strong&gt;T属性&lt;/strong&gt;）返回的是源数据视图（不会进行任何复制操作）。ndarray还有一个&lt;strong&gt;swapaxes&lt;/strong&gt;方法，它需要接受一对轴编号。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;数组索引&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数组切片索引：&lt;/strong&gt;数组切片是原始数组的视图。这意味着数据不会被复制，视图上的任何修改都会直接反映到原数组上。如果要得到ndarray切片的一份副本而非视图，就需要显式地进行复制操作，例如：&lt;code&gt;arr[5:8].copy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;布尔型索引：&lt;/strong&gt;通过布尔型索引选取得到的数组中的数据，将总是创建数据的副本，即使返回一模一样的数组也是如此。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;花式索引：&lt;/strong&gt;只需传入一个用于指定顺序的整数列表或者ndarray即可，它总是将数据复制到新数组中。如&lt;code&gt;arr[[4, 3, 0, 6]]&lt;/code&gt;。一次传入多个索引数据时，它返回的是一个一维数组，其中元素对应各个索引元素。选取一个矩形行列子集的方法可以为：&lt;code&gt;arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]]&lt;/code&gt;，或者使用&lt;code&gt;np.ix_&lt;/code&gt;函数，它可以将两个一维整数数组转换为一个用于选取正方形区域的索引器。&lt;code&gt;arr[np.ix_([1, 5, 7, 2], [0, 3, 1, 2])]&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;数组的集合运算&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;np.unique(x):&lt;/strong&gt;计算x中的唯一元素，并返回有序结果&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;np.intersect1d(x,y):&lt;/strong&gt;计算x和y中的公共元素，并返回有序结果&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;np.union1d(x,y):&lt;/strong&gt;计算x和y的并集，并返回有序结果&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;np.in1d(x,y):&lt;/strong&gt;用于测试一个数组中的值在另一个数组中的成员资格，得到一个表示“x的元素是否包含于y”的布尔型数组&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;

&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;in1d&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt; &lt;span class="n"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="n"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="n"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="n"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;False&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;dtype&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;np.setdiff1d(x,y):&lt;/strong&gt;集合的差，即元素在x中且不在y中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;np.setxor1d(x,y):&lt;/strong&gt;集合的对称差，即存在于一个数组中，但不同时存在于两个数组中的元素&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;数组的文件输入输出&lt;/h3&gt;
&lt;h4&gt;二进制格式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;np.save(fname, X)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;np.load(fname)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;np.savez(fname,a,b,...)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;savez_compressed&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;文本文件格式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;np.loatxt(filename, dtype, delimiter=' ', skiprows, usecols=(0,1,...), comments, converters={0:func0, 1:func1,...})&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;np.genfromtxt(...)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;np.fromfile(...)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;np.savetxt(filename,data,fmt="%d",delimiter)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;np.tofile(...)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;线性代数&lt;/h3&gt;
&lt;h4&gt;常用的numpy.linalg函数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;diag&lt;/strong&gt;：以一维数组的形式返回方阵的对角线（或非对角线）元素，或将一维数组转换成方阵（非对角线元素为0）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dot&lt;/strong&gt;：矩阵乘法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;trace&lt;/strong&gt;：计算对角线元素的和&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;det&lt;/strong&gt;：计算矩阵行列式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;eig&lt;/strong&gt;：计算方阵的本征值和本征向量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;inv&lt;/strong&gt;：计算方阵的逆&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pinv&lt;/strong&gt;：计算矩阵的Moore-Penrose伪逆&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;qr&lt;/strong&gt;：计算QR分解&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;svd&lt;/strong&gt;：计算奇异值分解（SVD）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;solve&lt;/strong&gt;：解线性方程组Ax = b， 其中A为一个方阵&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lstsq&lt;/strong&gt;：计算Ax = b 的最小二乘解&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;随机数生成&lt;/h3&gt;
&lt;h4&gt;部分numpy.random函数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;seed&lt;/strong&gt;：确定随机数生成器的种子&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;permutation&lt;/strong&gt;：返回一个序列的随机排列或返回一个随机排列的范围&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;shuffle&lt;/strong&gt;：对一个序列就地随机排序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rand&lt;/strong&gt;：产生一个均匀分布的样本值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;randint&lt;/strong&gt;：从给定的上下限范围内随机选取整数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;randn&lt;/strong&gt;：产生正态分布（平均值0，标准差为1）的样本值，类似于Matlab接口&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;binomial&lt;/strong&gt;：产生二项分布的样本值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;normal&lt;/strong&gt;：产生正态（高斯）分布的样本值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;beta&lt;/strong&gt;：产生Beta分布的样本值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;chisquare&lt;/strong&gt;：产生卡方分布的样本值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gamma&lt;/strong&gt;：产生Gamma分布的样本值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;uniform&lt;/strong&gt;：产生在[0, 1]中均匀分布的样本值&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Python"></category><category term="Numpy"></category></entry><entry><title>APM-Linux平台上用Make方法编译Pixhawk/PX4</title><link href="http://liung.github.io/blog/apm/2014-09-10-APM-Linux%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%94%A8Make%E6%96%B9%E6%B3%95%E7%BC%96%E8%AF%91Pixhawk%E5%92%8CPX4.html" rel="alternate"></link><updated>2014-09-10T17:24:31+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-09-10:blog/apm/2014-09-10-APM-Linux平台上用Make方法编译Pixhawk和PX4.html</id><summary type="html">&lt;h3&gt;快速开始&lt;/h3&gt;
&lt;p&gt;对于Ubuntu平台，采用下面步骤来编译代码。对于Linux其他平台，请参阅下面的更深入的说明&lt;/p&gt;
&lt;h4&gt;1、安装&lt;/h4&gt;
&lt;p&gt;安装git&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;qq&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;“克隆”源码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/diydrones/ardupilot.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行 install-prereqs-ubuntu.sh 脚本&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ardupilot&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Tools&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;scripts&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;install&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;prereqs&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ubuntu&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;重载路径(注销并再次登陆使其写入系统配置文件中)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;profile&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;2、编译&lt;/h4&gt;
&lt;p&gt;编译ArduCopter&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;ardupilot&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ArduCopter&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;configure&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;px4&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;v2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编译ArduPlane&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;ardupilot&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ArduPlane&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;configure&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;px4&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;v2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h3&gt;深入介绍&lt;/h3&gt;
&lt;p&gt;为了在Linux平台上编译PX4，你需要下面这些工具及Git代码库：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gcc-arm交叉编译器[&lt;a href="http://firmware.diydrones.com/Tools/PX4-tools/"&gt;here&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;ardupilot的git代码库[&lt;a href="https://github.com/diydrones/ardupilot"&gt;github.com/diydrones/ardupilot&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;PX4NuttX的git代码库[&lt;a href="https://github.com/diydrones/PX4NuttX"&gt;https://github.com/diydrones/PX4NuttX&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;PX4Firmware的git代码库[&lt;a href="https://github.com/diydrones/PX4Firmware"&gt;github.com/diydrones/PX4NuttX&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;GNU make，gawk和相关的linux标准编译工具&lt;/li&gt;
&lt;li&gt;Ubuntu平台你将需要安装genromfs工具包&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意的是你需要使用diydrones的github账户下的PX4nuttx和PX4Firmware代码库，而不是PX4下的。因为来自于PX4的代码库没有使用APM相关代码进行过验证。&lt;/p&gt;
&lt;h4&gt;设置权限&lt;/h4&gt;
&lt;p&gt;你需要将你当前用户添加到dialout群组中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;usermod&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;dialout&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;USER&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注销并再次登陆是群组操作生效。&lt;/p&gt;
&lt;p&gt;还有，值得注意的是确保没有安装modemmanager包（调制解调器管理），并且modem-manager进程没有运行。&lt;/p&gt;
&lt;h4&gt;目录结构&lt;/h4&gt;
&lt;p&gt;Ardupilot、PX4Nuttx和PX4Firmware的git代码需要放在同一个目录下。因为目录中的makefile文件将在Ardupilot目录的上层目录寻找PX4Nuttx和PX4Firmware。&lt;/p&gt;
&lt;h4&gt;编译器&lt;/h4&gt;
&lt;p&gt;需要指定gcc-arm交叉编译器链接上述文件。&lt;/p&gt;
&lt;p&gt;首先，你需要解压编译器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;tar&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;xjvf&lt;/span&gt; &lt;span class="n"&gt;gcc&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;arm&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;none&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;eabi&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="n"&gt;_6&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2012&lt;/span&gt;&lt;span class="n"&gt;q2&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;20120614.&lt;/span&gt;&lt;span class="n"&gt;tar&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bz2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后编辑$HOME/.bashrc文件，在文件末尾添加如下链接，将原始代码中的bin目录添加到你的环境变量中&lt;code&gt;%PATH&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;export&lt;/span&gt; &lt;span class="n"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;:/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;your_username&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;gcc&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;arm&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;none&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;eabi&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="n"&gt;_6&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2012&lt;/span&gt;&lt;span class="n"&gt;q2&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;快速编译工具ccache&lt;/h4&gt;
&lt;p&gt;安装ccache工具将极大加速你的编译时间。一旦你安装了它（例如通过“&lt;code&gt;sudo apt-get install ccache&lt;/code&gt;”）你应该像这样链接编译器到/usr/lib/ccache。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lib&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ccache&lt;/span&gt;
&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;ln&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ccache&lt;/span&gt; &lt;span class="n"&gt;arm&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;none&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;eabi&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;
&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;ln&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ccache&lt;/span&gt; &lt;span class="n"&gt;arm&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;none&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;eabi&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gcc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后像前面一样将/usr/lib/ccache加入你的环境变量里&lt;code&gt;%PATH&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;编译&lt;/h4&gt;
&lt;p&gt;当你下载好了上述三个git代码库并配置完成编译器，就可以在你的飞行器目录开始编译工作。例如，编译ArduPlane：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;ardupilot&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ArduPlane&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;configure&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;px4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编译完成后将生成两个文件：ArduPlane-v1.px4 和 ArduPlane-v2.px4。v1文件针对PX4V1平台，V2针对PX4v2平台（Pixhawk）。&lt;/p&gt;
&lt;p&gt;同样可以使用&lt;code&gt;make px4-v1&lt;/code&gt;或者&lt;code&gt;make px4-v2&lt;/code&gt;来编译对应平台文件。&lt;/p&gt;
&lt;p&gt;第一次编译时间可能有点漫长，因为它需要编译整个px4的文件架构。之后的编译过程将变得非常快（特别是你正确地设置了ccache）。&lt;/p&gt;
&lt;h4&gt;加载固件&lt;/h4&gt;
&lt;p&gt;使用下面的命令将固件加载到飞控板上：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;px4&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;upload&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;px4&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;v2&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;upload&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当通过USB向你的PX4加载代码提示“waiting for bootloader”之后。&lt;/p&gt;
&lt;p&gt;如果在擦出阶段上传总是失败，检查是否运行了modemmanager，它可以控制PX4的USB端口。如果是，尝试移除modemmanager来获得帮助。&lt;/p&gt;
&lt;h4&gt;清理&lt;/h4&gt;
&lt;p&gt;更新完成git代码后，你可能需要一个干净的编译结果。使用下面命令来实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;px4&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;clean&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这将会移除编译过程的PX4Nuttx文件架构信息以便于重新编译。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;链接&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/building-px4-for-linux-with-make/"&gt;APM官网原文链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html"&gt;APM开发人员参考手册目录列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;(over)&lt;/em&gt;&lt;/p&gt;&lt;script type= "text/javascript"&gt;
    if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
        var mathjaxscript = document.createElement('script');
        mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
        mathjaxscript.type = 'text/javascript';
        mathjaxscript.src = 'https:' == document.location.protocol
                ? 'https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'
                : 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
        mathjaxscript[(window.opera ? "innerHTML" : "text")] =
            "MathJax.Hub.Config({" +
            "    config: ['MMLorHTML.js']," +
            "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
            "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
            "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
            "    displayAlign: 'center'," +
            "    displayIndent: '0em'," +
            "    showMathMenu: true," +
            "    tex2jax: { " +
            "        inlineMath: [ ['$','$'] ], " +
            "        displayMath: [ ['$$','$$'] ]," +
            "        processEscapes: true," +
            "        preview: 'TeX'," +
            "    }, " +
            "    'HTML-CSS': { " +
            "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }" +
            "    } " +
            "}); ";
        (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
    }
&lt;/script&gt;
</summary><category term="APM"></category><category term="飞控板"></category><category term="硬件"></category></entry><entry><title>APM-Linux平台上用Make方法编译APM2.x</title><link href="http://liung.github.io/blog/apm/2014-09-10-APM-Linux%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%94%A8Make%E6%96%B9%E6%B3%95%E7%BC%96%E8%AF%91APM2.x.html" rel="alternate"></link><updated>2014-09-10T17:18:44+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-09-10:blog/apm/2014-09-10-APM-Linux平台上用Make方法编译APM2.x.html</id><summary type="html">&lt;h3&gt;快速开始&lt;/h3&gt;
&lt;p&gt;对于Ubuntu平台，采用下面步骤来编译代码。对于Linux其他平台，请参阅下面的更深入的说明&lt;/p&gt;
&lt;h4&gt;1、安装&lt;/h4&gt;
&lt;p&gt;安装git&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;qq&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;“克隆”源码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/diydrones/ardupilot.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行 install-prereqs-ubuntu.sh 脚本&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ardupilot&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Tools&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;scripts&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;install&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;prereqs&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ubuntu&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;重载路径(注销并再次登陆使其写入系统配置文件中)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;profile&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;2、编译&lt;/h4&gt;
&lt;p&gt;编译ArduCopter&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;ardupilot&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ArduCopter&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;configure&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编译ArduPlane&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;ardupilot&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ArduPlane&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;configure&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h3&gt;深入介绍&lt;/h3&gt;
&lt;p&gt;为了在Linux上编译Ardupilot固件，你需要一个针对板子芯片的类型相同的特定编译器。如果你使用的是基于Ubuntu发布框架的debian系统，可以使用下面命令获取你所需要的核心包：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;gcc&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;avr&lt;/span&gt; &lt;span class="n"&gt;avrdude&lt;/span&gt; &lt;span class="n"&gt;avr&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;libc&lt;/span&gt; &lt;span class="n"&gt;binutils&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;avr&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此外，使用SITL系统和开发者工具还需要一些其他的辅助工具。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;python&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;serial&lt;/span&gt; &lt;span class="n"&gt;python&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;wxgtk2&lt;/span&gt;&lt;span class="mf"&gt;.8&lt;/span&gt; &lt;span class="n"&gt;python&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;matplotlib&lt;/span&gt; &lt;span class="n"&gt;python&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;opencv&lt;/span&gt; &lt;span class="n"&gt;python&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pexpect&lt;/span&gt; &lt;span class="n"&gt;python&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;scipy&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;安装完成之后，你就可以切换到你需要编译的的飞行器目录，通过运行&lt;code&gt;make&lt;/code&gt;来编译你想要的代码。具体编译目标列表请查看mk/targets.mk。&lt;/p&gt;
&lt;h4&gt;Ubuntu Linux&lt;/h4&gt;
&lt;p&gt;Ubuntu上针对APM1/APM2(arduino)系统的编译还需要下面的工具。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;gawk&lt;/span&gt; &lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;arduino&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;core&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编译PX4平台的Ardupilot，首先需要安装PX4工具链，并下载PX4源代码。查看&lt;strong&gt;PX4 工具链安装页面 &lt;/strong&gt;(&lt;a href="https://pixhawk.ethz.ch/px4/dev/toolchain_installation_lin"&gt;Here!&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;安装这些需要的工具最简单的方法是运行&lt;code&gt;ardupilot/Tools/scripts/install-prereqs-ubuntu.sh&lt;/code&gt;脚本，来自动安装所需包和工具。&lt;/p&gt;
&lt;h4&gt;Building using make&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;在第一次编译代码前，需要在sketch（i.e. ArduPlane, ArduCopter, etc…）目录运行&lt;code&gt;make configure&lt;/code&gt;.它将在代码库的顶层目录创建一个&lt;code&gt;config.mk&lt;/code&gt;文件，你可以查看该文件内的默认设置。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在sketch目录，运行 &lt;code&gt;make&lt;/code&gt;来编译APM2。&lt;code&gt;make apm1&lt;/code&gt; 将编译为APM1平台文件，&lt;code&gt;make px4&lt;/code&gt;将编译为px4平台文件.二进制文件保存在&lt;code&gt;/tmp/sketchname.build&lt;/code&gt;目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行&lt;code&gt;make upload&lt;/code&gt;加载固件. 需要在 &lt;code&gt;config.mk&lt;/code&gt;文件中设置正确的默认串行端口.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h4&gt;链接&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/building-the-code-onlinux/"&gt;APM官网原文链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html"&gt;APM开发人员参考手册目录列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;(over)&lt;/em&gt;&lt;/p&gt;</summary><category term="APM"></category><category term="飞控板"></category><category term="硬件"></category></entry><entry><title>APM-MacOS平台上用Make方法编译Pixhawk/PX4</title><link href="http://liung.github.io/blog/apm/2014-09-08-APM-MacOS%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%94%A8Make%E6%96%B9%E6%B3%95%E7%BC%96%E8%AF%91Pixhawk%E5%92%8CPX4.html" rel="alternate"></link><updated>2014-09-08T09:27:32+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-09-08:blog/apm/2014-09-08-APM-MacOS平台上用Make方法编译Pixhawk和PX4.html</id><summary type="html">&lt;h3&gt;MAC (ver 10.6 onwards)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、&lt;/strong&gt;Install Homebrew for Mac OS X&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、&lt;/strong&gt;Install the following packages using brew&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;brew tap PX4/homebrew-px4&lt;/li&gt;
&lt;li&gt;brew update&lt;/li&gt;
&lt;li&gt;brew install genromfs&lt;/li&gt;
&lt;li&gt;brew install gcc-arm-none-eabi&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3、&lt;/strong&gt;Install pip and pyserial using the following commands:
- sudo easy_install pip
- sudo pip install pyserial&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、&lt;/strong&gt;Now create your directory and install all the software:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mkdir -p px4&lt;/li&gt;
&lt;li&gt;cd px4&lt;/li&gt;
&lt;li&gt;git clone https://github.com/diydrones/ardupilot.git&lt;/li&gt;
&lt;li&gt;git clone https://github.com/diydrones/PX4Firmware.git&lt;/li&gt;
&lt;li&gt;git clone https://github.com/diydrones/PX4NuttX.git&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;5、&lt;/strong&gt;Now set-up the configuration file for building ArduCopter using the following commands:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cd ardupilot/ArduCopter&lt;/li&gt;
&lt;li&gt;make configure&lt;/li&gt;
&lt;li&gt;open the ardupilot/config.mk file and make the following changes:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PX4_ROOT=../PX4Firmware (this should point to your PX4Firmware directory)&lt;/p&gt;
&lt;p&gt;NUTTX_SRC=../PX4NuttX/nuttx (this should point to nuttx)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;make   (the first time through it will build the PX4Firmware and NuttX)&lt;/li&gt;
&lt;li&gt;make   (this time it will build the ArduCopter firmware)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;6、&lt;/strong&gt;Build the arducopter software for px4 using the following commands:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cd ardupilot/ArduCopter&lt;/li&gt;
&lt;li&gt;make px4-quad&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You should find two files in the ArduCopter directory. ArduCopter-v1.px4 is for the original PX4, ArduCopter-v2.px4 is for the pixhawk.&lt;/p&gt;
&lt;p&gt;Occasionally you should pull PX4Firmware and PX4NuttX updates. To make sure it compiles correctly, run the clean option in make:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;make px4-clean&lt;/li&gt;
&lt;li&gt;make px4-[frame type]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The available frame types are quad, tri, hexa, y6, octa, octa-quad, hell&lt;/p&gt;
&lt;p&gt;To make and upload to your vehicle:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;make px4-quad-upload&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4&gt;链接&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/building-px4-with-make-on-mac/"&gt;APM官网原文链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html"&gt;APM开发人员参考手册目录列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;(over)&lt;/em&gt;&lt;/p&gt;</summary><category term="APM"></category><category term="飞控板"></category><category term="硬件"></category></entry><entry><title>APM-MacOS平台上用Arduino编译APM2.x</title><link href="http://liung.github.io/blog/apm/2014-09-08-APM-MacOS%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%94%A8Arduino%E7%BC%96%E8%AF%91APM2.x.html" rel="alternate"></link><updated>2014-09-08T09:02:28+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-09-08:blog/apm/2014-09-08-APM-MacOS平台上用Arduino编译APM2.x.html</id><summary type="html">

&lt;p&gt;在MacOS平台上针对AVR芯片的Ardupilot的源码编译可以有两种选择。第一种是使用特殊版的Arduino编译环境。你可以在&lt;a href="http://firmware.diydrones.com/"&gt;http://firmware.diydrones.com/&lt;/a&gt;的工具目录下获得。第二种选择是使用&lt;code&gt;make&lt;/code&gt;命令行工具进行编译。&lt;/p&gt;


&lt;p&gt;如果你选择Arduino工具，当你安装完成之后，你还需要做下面这些事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Ardupilot菜单下选择你的飞控板类型&lt;/li&gt;
&lt;li&gt;在菜单File--&amp;gt;&amp;gt;属性Preferences下设置Sketchbook位置到你的Ardupilot源码目录&lt;/li&gt;
&lt;li&gt;关闭并重启Arduino&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4&gt;链接&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/building-the-code-on-mac/"&gt;APM官网原文链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html"&gt;APM开发人员参考手册目录列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;(over)&lt;/em&gt;&lt;/p&gt;</summary><category term="APM"></category><category term="飞控板"></category><category term="硬件"></category></entry><entry><title>APM-Windows平台上用Make方法编译Pixhawk和PX4</title><link href="http://liung.github.io/blog/apm/2014-09-07-APM-Windows%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%94%A8Make%E6%96%B9%E6%B3%95%E7%BC%96%E8%AF%91Pixhawk%E5%92%8CPX4.html" rel="alternate"></link><updated>2014-09-07T13:59:57+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-09-07:blog/apm/2014-09-07-APM-Windows平台上用Make方法编译Pixhawk和PX4.html</id><summary type="html">

&lt;h3&gt;Windows平台&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、&lt;/strong&gt; 安装&lt;a href="http://windows.github.com/"&gt;Github for Windows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、&lt;/strong&gt; 确保你的 github 上关于行尾结束符的设置没有发生变动。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当你安装了Git 后，“Git shell（or Bash）”也会安装好。点击“Git shell（or Bash）”图标，然后在弹出的Git “MINGW32”终端窗口键入：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git config --global core.autocrlf false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、&lt;/strong&gt;“克隆”（clone）Ardupilot，PX4Firmware和PX4NuttX代码库到你的本地电脑上：&lt;/p&gt;


&lt;ul&gt;
&lt;li&gt;到 &lt;a href="https://github.com/diydrones/ardupilot"&gt;GitHub/diydrones/ardupilot&lt;/a&gt; 的web页面点击“Clone in Desktop”按钮&lt;/li&gt;
&lt;li&gt;到&lt;a href="https://github.com/diydrones/PX4Firmware"&gt; GitHub/diydrones/PX4Firmware &lt;/a&gt;的web页面点击“Clone in Desktop”按钮&lt;/li&gt;
&lt;li&gt;到&lt;a href="https://github.com/diydrones/PX4NuttX"&gt; GitHub/diydrones/PX4NuttX &lt;/a&gt;的web页面点击“Clone in Desktop”按钮&lt;/li&gt;
&lt;li&gt;&lt;img alt="img1" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/06/BuildingTheCode_PX4OnWindows1.png" /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4、&lt;/strong&gt;运行&lt;a href="http://www.inf.ethz.ch/personal/lomeier/downloads/px4_toolchain_installer_v12_win.exe"&gt; px4_toolchain_installer_v12_win.exe &lt;/a&gt;下载并安装PX4工具链（在&lt;a href="http://pixhawk.org/firmware/downloads#px4_arm_toolchain"&gt;该页面&lt;/a&gt;的底部搜索“PX4 Toolchain Installer”）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、&lt;/strong&gt;创建并定制config.mk文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;win7平台上可以在开始&amp;gt;&amp;gt;所有程序&amp;gt;&amp;gt;PX4 Toolchain找到PX4Console，并运行。或者直接去该目录C:\px4\toolchain\msys\1.0\px4_console.bat运行。&lt;/li&gt;
&lt;li&gt;“cd”到步骤三中Ardupilot固件的文件目录，然后进入ArduCopter目录（确保这里ArduCopter中的A和C都是大写形式）。在命令行中可以这样执行：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;cd /c/Users/&amp;lt;username&amp;gt;/Documents/GitHub/ardupilot/ArduCopter&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过下命令行中键入下列命令创建config.mk。系统将会出现下面的警示信息：包含有文件准确链接位置的config.mk文件已经创建并写入。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;make configure&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果步骤三中创建PX4Firmware和PX4NuttX仓库时使用了相同的名字和位置，那么就不需要更改config.mk文件。但是如果名字或者位置有一个不同，那你就需要用诸如&lt;a href="http://notepad-plus-plus.org/download/v6.4.5.html"&gt;NotePad++&lt;/a&gt;等文本编辑器打开config.mk，并将PX4_ROOT和/或NUTTX_SRC值设置正确。&lt;/p&gt;
&lt;p&gt;&lt;img alt="img2" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/06/BuildingTheCode_PX4OnWindows2.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、&lt;/strong&gt;打开PX4控制台开始编译固件，首先切换到ArduCopter目录，然后输入下面命令执行编译&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;make px4&lt;/code&gt;                &amp;lt;– 将会编译四旋翼形式的PX4和PixHawk固件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make px4-v2&lt;/code&gt;           &amp;lt;– 将会编译四旋翼形式的PixHawk固件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make px4-v2-hexa&lt;/code&gt;  &amp;lt;–将会编译六旋翼形式的PixHawk固件(其它可支持的后缀名包括“octa”和"heli")&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make clean&lt;/code&gt;             &amp;lt;– 清理（“clean”） ardupilot 文件目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make px4-clean&lt;/code&gt;      &amp;lt;– 清理（“clean”）PX4Firmware 和 PX4NuttX  文件目录以便于下次重新编译&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make px4-v2-upload&lt;/code&gt;  &amp;lt;– 编译并加载 Pixhawk 的四旋翼固件(如果使用该命令，那么就不需要执行下面的步骤七了)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编译好的固件以.px4文件扩展名结尾，位于在ArduCopter目录&lt;/p&gt;
&lt;p&gt;&lt;img alt="img3" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/06/PX4_ArduCopter_Build.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、&lt;/strong&gt;使用Mission Planner 加载固件的方法：初始设置（Initial Setup）&amp;gt;&amp;gt;安装固件（Install Firmware）界面点击“Load custom firmware”链接&lt;/p&gt;
&lt;h3&gt;加快编译时间的一些小建议&lt;/h3&gt;
&lt;p&gt;杀毒防护软件有可能会减慢编译时间，特别对PX4尤为明显，所以建议包含有Ardupilot、PX4Firmware和PX4NuttX源代码的文件夹不在你的杀毒软件实时扫描范围内。&lt;/p&gt;
&lt;p&gt;当执行完&lt;code&gt;make px4-clean&lt;/code&gt;后第一次编译将会非常的慢，因为要重新编译每一个文件。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;链接&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/building-px4-with-make/"&gt;APM官网原文链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html"&gt;APM开发人员参考手册目录列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;(over)&lt;/em&gt;&lt;/p&gt;</summary><category term="APM"></category><category term="飞控板"></category><category term="硬件"></category></entry><entry><title>APM-Windows平台上用Arduino编译ArduPilot</title><link href="http://liung.github.io/blog/apm/2014-09-06-APM-Windows%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%94%A8Arduino%E7%BC%96%E8%AF%91ArduPilot.html" rel="alternate"></link><updated>2014-09-06T15:34:19+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-09-06:blog/apm/2014-09-06-APM-Windows平台上用Arduino编译ArduPilot.html</id><summary type="html">

&lt;p&gt;&lt;strong&gt;版本要求： Copter 3.1， Plane 2.76&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;硬件要求： APM 2.0,2.5,2.6&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;img alt="apm" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image001.jpg" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Step 1 安装Git-SCM&lt;/h3&gt;
&lt;p&gt;软件链接： &lt;a href="http://git-scm.com/download/win"&gt;http://git-scm.com/download/win&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在安装过程中请按照下面的截图勾选相应的选项。&lt;/p&gt;
&lt;p&gt;&lt;img alt="img1" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image004.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="img2" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image006.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;在欢迎界面和许可证界面点击Next按钮&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img alt="img3" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image008.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="img4" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image018.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;在选择组件点击Next按钮，然后点击Finish按钮。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img alt="img5" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image014.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="img6" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image016.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;在替换用户文件界面点击Next按钮，然后等待Git完成安装。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img alt="img7" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image012.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="img8" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image010.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;如上图，选择切换到window风格（checkout windows-style），然后点击Next按钮，选择从windows命令界面运行Git，点击Next按钮。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Step 2 下载源码&lt;/h3&gt;
&lt;p&gt;首先在你电脑的C盘，建立一个名为GIT的文件夹。&lt;/p&gt;
&lt;p&gt;用windows资源管理器到该文件夹下。&lt;/p&gt;
&lt;p&gt;&lt;img alt="img9" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image020.jpg" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;然后在文件夹空白地方右击选择git Bash选项。&lt;/p&gt;
&lt;p&gt;&lt;img alt="img10" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image022.jpg" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;此时，屏幕上会弹出下面的窗口。&lt;/p&gt;
&lt;p&gt;&lt;img alt="img11" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image024.jpg" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;在该命令窗口中，键入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/diydrones/ardupilot.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="img26" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image026.jpg" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;当命令执行完毕之后，应该像下面这样...&lt;/p&gt;
&lt;p&gt;&lt;img alt="img12" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image028.jpg" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Step 3 安装MHV_AVR_Tools到软件默认位置&lt;/h3&gt;
&lt;p&gt;软件链接：&lt;a href="http://firmware.diydrones.com/Tools/Arduino/MHV_AVR_Tools_20121007.exe"&gt;http://firmware.diydrones.com/Tools/Arduino/MHV_AVR_Tools_20121007.exe&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="img13" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image030.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="img14" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image038.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;安装引导界面点击Next按钮然后选择Install按钮开始安装&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img alt="img15" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image036.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="img16" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image034.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;在选择组件界面两项都勾选，然后点击Next按钮，选择安装到默认位置。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img alt="img17" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image032.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;在许可证界面点击同意（I Agree）完成安装。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Step 4 安装Ardupilot-Arduino&lt;/h3&gt;
&lt;p&gt;接下来下载特定版本的 ArduPilot Arduino 压缩包。&lt;/p&gt;
&lt;p&gt;这里有一个新版本的，采用GCC 4.7.2编译。&lt;/p&gt;
&lt;p&gt;地址：&lt;a href="http://firmware.diydrones.com/Tools/Arduino/ArduPilot-Arduino-1.0.3-gcc-4.8.2-windows.zip"&gt;http://firmware.diydrones.com/Tools/Arduino/ArduPilot-Arduino-1.0.3-gcc-4.8.2-windows.zip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我将该文件解压到我电脑上的C盘。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Step 5 配置Arduino&lt;/h3&gt;
&lt;p&gt;打开放置Arduino的文件夹&lt;/p&gt;
&lt;p&gt;&lt;img alt="img18" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image0401.jpg" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;双击Arduino图标&lt;/p&gt;
&lt;p&gt;&lt;img alt="img19" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image040.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;当Arduino打开之后，到文件（file）菜单栏&lt;/p&gt;
&lt;p&gt;&lt;img alt="img20" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image042.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;点击属性&lt;/p&gt;
&lt;p&gt;&lt;img alt="img21" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image044.png" /&gt;&lt;/p&gt;
&lt;p&gt;设置Sketchbook到你电脑上GIT文件夹下的Ardupilot目录&lt;/p&gt;
&lt;p&gt;同样选择编译和加载选项，这样在执行相应功能时就可以查看到详细信息。&lt;/p&gt;
&lt;p&gt;不要选择启动时自动升级功能（该版本是针对Ardupilot的特殊版本）&lt;/p&gt;
&lt;p&gt;点击OK，然后关闭Arduino&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Step 6 通过USB连接你的APM&lt;/h3&gt;
&lt;p&gt;重新打开Arduino，然后在file菜单栏中点击Sketchbook，选择你想要加载到你的APM2.x上的程序代码（比如这里选择ArduCopter,其它采用同样的方法设置）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="img22" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image047.jpg" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;一旦文件加载完成，点击Ardupilot菜单，选择HAL板下的Ardupilot Mega 2.x&lt;/p&gt;
&lt;p&gt;&lt;img alt="img23" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image049.jpg" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;然后点击Tools菜单，选择Board 选项卡下的 Arduino Mega 2560 or Mega ADK&lt;/p&gt;
&lt;p&gt;&lt;img alt="img24" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image051.jpg" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;接下来重新选择Tools菜单，设置你的APM连接到电脑上的端口号Serial Port&lt;/p&gt;
&lt;p&gt;&lt;img alt="img25" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image053.jpg" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;在这个例子中为COM4，你可以在你的电脑的设备管理器中，在端口Ports中查看APM对应的端口。&lt;/p&gt;
&lt;p&gt;&lt;img alt="img27" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image055.jpg" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Step 7 配置Arducopter&lt;/h3&gt;
&lt;p&gt;点击文件APM_Config.h选项卡。&lt;/p&gt;
&lt;p&gt;设置你的飞行器构型（例如&lt;code&gt;#define FRAME_CONFIG HEXA_FRAME&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;在该文件中可以启用/不启用相应的功能。&lt;/p&gt;
&lt;p&gt;例如：如果在编译过程中想让auto tune 功能失效，那么你可以简单的将该行取消注释&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//# AUTOTUNE              DISABLED            // 不启用该功能可以节省7k的闪存空间&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;改为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# AUTOTUNE              DISABLED            // 不启用该功能可以节省7k的闪存空间&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;默认是启用该功能。&lt;/p&gt;
&lt;p&gt;源代码中所有注释掉的功能都不是默认的，你需要做的就是通过取消注释来改变系统的默认选项&lt;/p&gt;
&lt;p&gt;保存该文件然后选择文件Arducopter&lt;/p&gt;
&lt;p&gt;接下来就可以准备开始编译了。&lt;/p&gt;
&lt;p&gt;但一般来讲我会先选择校验（verify）代码。&lt;/p&gt;
&lt;p&gt;&lt;img alt="img28" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image057.jpg" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Step 8 将代码加载到你的Ardupilot板上&lt;/h3&gt;
&lt;p&gt;点击编译按钮&lt;/p&gt;
&lt;p&gt;&lt;img alt="img29" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image058.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;这可能会花费一些时间...&lt;/p&gt;
&lt;p&gt;当出现下面提示时表明编译完成...&lt;/p&gt;
&lt;p&gt;&lt;img alt="img30" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/11/image061.jpg" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;最后用地面站软件Mission Planner确认能否正常使用&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;注意&lt;/h3&gt;
&lt;p&gt;你自己配置并编译过的代码是没有经过测试的，请仅仅将它用来做测试之用。如果你没有足够的把握，建议你使用Mission Planner来加载预先编译过的代码。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;升级你的代码&lt;/h3&gt;
&lt;p&gt;请确认你电脑上的代码为最新版，否则就用git来升级你的代码到最新版本。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;链接&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/building-ardupilot-with-arduino-windows/"&gt;APM官网原文链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html"&gt;APM开发人员参考手册目录列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;(over)&lt;/em&gt;&lt;/p&gt;</summary><category term="APM"></category><category term="飞控板"></category><category term="硬件"></category></entry><entry><title>APM-编译代码</title><link href="http://liung.github.io/blog/apm/2014-09-06-APM-%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81.html" rel="alternate"></link><updated>2014-09-06T14:03:34+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-09-06:blog/apm/2014-09-06-APM-编译代码.html</id><summary type="html">

&lt;p&gt;下面这些页面的链接，将提供给你更多关于如何编译APM2.x和PX4的飞行器控制和地面站源码的信息。&lt;/p&gt;


&lt;hr /&gt;
&lt;h3&gt;APM:Plane,Copter,Rover:&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Windows用户：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-09-06-APM-Windows平台上用Arduino编译ArduPilot.html"&gt;Windows平台上用Arduino编译ArduPilot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-09-07-APM-Windows平台上用Make方法编译Pixhawk和PX4.html"&gt;Windows平台上用Make方法编译Pixhawk/PX4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/building-the-code/wiki/building-ardupilot-apm-with-visual-studio-visual-micro/"&gt;使用Atmel Studio或者Visual Studio编译APM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;MacOS用户：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-09-08-APM-MacOS平台上用Arduino编译APM2.x.html"&gt;MacOS平台上用Arduino编译APM2.x&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-09-08-APM-MacOS平台上用Make方法编译Pixhawk和PX4.html"&gt;MacOS平台上用Make方法编译Pixhawk/PX4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Linux用户：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-09-10-APM-Linux平台上用Make方法编译APM2.x.html"&gt;Linux平台上用Make方法编译APM2.x&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-09-10-APM-Linux平台上用Make方法编译Pixhawk和PX4.html"&gt;Linux平台上用Make方法编译Pixhawk/PX4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/building-for-beaglebone-black-on-linux/"&gt;Linux平台上用Make方法编译BeagleBone Black&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;地面站Mission Planner：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/building-the-code/wiki/compile-mission-planner/"&gt;Windows平台上使用Visual Studio编译Mission Planner&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4&gt;链接&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/building-the-code/"&gt;APM官网原文链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html"&gt;APM开发人员参考手册目录列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;(over)&lt;/em&gt;&lt;/p&gt;</summary><category term="APM"></category><category term="飞控板"></category><category term="硬件"></category></entry><entry><title>APM-增加新的MAVLink通讯协议消息</title><link href="http://liung.github.io/blog/apm/2014-09-05-APM-%E5%A2%9E%E5%8A%A0%E6%96%B0%E7%9A%84MAVLink%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E6%B6%88%E6%81%AF.html" rel="alternate"></link><updated>2014-09-05T14:41:58+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-09-05:blog/apm/2014-09-05-APM-增加新的MAVLink通讯协议消息.html</id><summary type="html">&lt;h3&gt;综述&lt;/h3&gt;
&lt;p&gt;地面站之间的数据和指令通信都是通过串行接口使用&lt;a href="http://en.wikipedia.org/wiki/MAVLink"&gt;MAVLink协议&lt;/a&gt;来传递的。本页面将提供关于添加新的MAVLink信息的一些高级建议。&lt;/p&gt;
&lt;p&gt;这些指令仅在Liunx上测试完成（通过Windows上虚拟机运行的Ubuntu）。关于设置虚拟机的方法在&lt;a href="http://dev.ardupilot.com/wiki/code-overview-adding-a-new-mavlink-message/wiki/setting-up-sitl-on-windows/"&gt;SITL(软件层面仿真)页面&lt;/a&gt;有相关介绍。如果你要运行SITL，你最好遵循下面的一些建议。这些指令不能直接在Windows或者Mac平台上本地运行。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Step #1&lt;/strong&gt;：确保你已经安装了最新的ardupilot代码，同时也检查一下mavproxy是否是最新版本。mavproxy工具可以通过在终端窗口运行下面命令进行升级。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;upgrade&lt;/span&gt; &lt;span class="n"&gt;mavproxy&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Step #2&lt;/strong&gt;：先确定你所要添加的信息的类型，以及如何和已有的&lt;a href="https://pixhawk.ethz.ch/mavlink/"&gt;MavLink消息&lt;/a&gt;兼容。&lt;/p&gt;
&lt;p&gt;比如：你可能会想要向飞行器发送一个新的导航指令，让它可以在任务中期（自动模式中）模仿一个特技动作（比如翻筋斗）。在这个例子中，你需要一个类似于&lt;code&gt;MAV_CMD_NAV_WAYPOINT&lt;/code&gt;（可以在&lt;a href="https://pixhawk.ethz.ch/mavlink/"&gt;MAVLink消息页面&lt;/a&gt;搜索&lt;code&gt;MAV_CMD_NAV_WAYPOINT&lt;/code&gt;）一样的新的导航指令&lt;code&gt;MAV_CMD_NAV_TRICK&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;又或者你想要从飞行器发送一个新的传感器数据类型到地面站,可能类似于&lt;a href="https://pixhawk.ethz.ch/mavlink/#SCALED_PRESSURE"&gt;SCALED_PRESSURE&lt;/a&gt;消息。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Step #3&lt;/strong&gt;：在&lt;a href="https://github.com/diydrones/ardupilot/blob/master/libraries/GCS_MAVLink/message_definitions/common.xml"&gt;common.xml&lt;/a&gt;和&lt;a href="https://github.com/diydrones/ardupilot/blob/master/libraries/GCS_MAVLink/message_definitions/ardupilotmega.xml"&gt;ardupilotmega.xml&lt;/a&gt;文件中添加你的信息的定义声明。&lt;/p&gt;
&lt;p&gt;如果你希望将该指令添加到MAVLink协议中，那么你应该添加该指令到../ardupilot/libraries/GCS_MAVLink/message_definitions/common.xml文件中。如果你仅仅个人使用或者仅仅和ArduCopter，ArduPlane，ArduRover搭配使用，那么它就应该被添加到ardupimega.xml文件中。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Step #4&lt;/strong&gt;：重新生成你的所有inlcude文件，确保添加的信息在主代码中可以被识别。&lt;/p&gt;
&lt;p&gt;首先将目录切换到ardupilot文件夹下，然后执行下面命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;libraries&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;GCS_MAVLink&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;generate&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;成功执行后，你应该看到下面这些文件都应经被更新。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;../libraries/GCS_MAVLink/include/mavlink/v1.0/ardupilotmega/ardupilotmega.h&lt;/span&gt;
&lt;span class="cp"&gt;../libraries/GCS_MAVLink/include/mavlink/v1.0/ardupilotmega/version.h&lt;/span&gt;
&lt;span class="cp"&gt;../libraries/GCS_MAVLink/include/mavlink/v1.0/common/version.h&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;文件version.h仅简单的更新了文件的日期和时间，但是ardupilotmega.h文件已经应该有了你的新消息的定义声明。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Step #5&lt;/strong&gt;：在飞行器主代码中添加函数方法用来控制向/从地面站发送/接收指令。&lt;/p&gt;
&lt;p&gt;这些顶层代码指令绝大部分包含在飞行器的&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/GCS_Mavlink.pde"&gt;GCS_MAVLink.pde&lt;/a&gt;文件中或在&lt;a href="https://github.com/diydrones/ardupilot/blob/master/libraries/GCS_MAVLink/GCS.h"&gt;../libraries/GCS_MAVLink/GCS&lt;/a&gt;类中。&lt;/p&gt;
&lt;p&gt;在我们想要添加一个新的导航指令的例子中（比如执行特技动作），应该需要下面信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;扩展&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_Mission"&gt;AP_Mission库&lt;/a&gt;中的&lt;code&gt;mission_cmd_to_mavlink()&lt;/code&gt;和&lt;code&gt;mavlink_to_mission_cmd()&lt;/code&gt;方法，将mavproxy的指定转换到一个&lt;code&gt;AP_Mission::Mission_Command&lt;/code&gt;结构体中。&lt;/li&gt;
&lt;li&gt;在飞行器的&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/commands_logic.pde"&gt;commands_logic.pde&lt;/a&gt;文件中分别添加&lt;code&gt;start_command()&lt;/code&gt;函数和&lt;code&gt;verify_command()&lt;/code&gt;函数的一个&lt;code&gt;case&lt;/code&gt;分支，用来校验新的消息指令&lt;code&gt;MAV_CMD_NAV_TRICK&lt;/code&gt;是否接收到。这些需要你调用自己创建的两个新函数&lt;code&gt;do_trick()&lt;/code&gt;和&lt;code&gt;verify_trick()&lt;/code&gt;（具体参考下面）。&lt;/li&gt;
&lt;li&gt;创建两个新函数&lt;code&gt;do_trick()&lt;/code&gt;和&lt;code&gt;verify_trick()&lt;/code&gt;，用来控制飞行器如何执行特技动作（这可能需要调用&lt;a href=""&gt;control_auto.pde&lt;/a&gt;中的另一个函数来设置&lt;code&gt;auto_mode&lt;/code&gt;变量，然后调用新方法&lt;code&gt;auto_trick_start()&lt;/code&gt;）。当指令第一次被唤醒时将使用&lt;code&gt;do_trick()&lt;/code&gt;函数。&lt;code&gt;verify_trick()&lt;/code&gt;函数将会以10hz频率（或者更高）被重复调用直到特技动作完成，当特技动作执行完毕之后&lt;code&gt;verify_trick()&lt;/code&gt;函数应该返回&lt;code&gt;True&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Step #6&lt;/strong&gt;：考虑是否发布你的代码到主代码仓库中。&lt;/p&gt;
&lt;p&gt;你可以发邮件到&lt;a href="https://groups.google.com/forum/#!forum/drones-discuss"&gt;drones-discuss email list&lt;/a&gt;并且/或者&lt;a href="http://dev.ardupilot.com/wiki/code-overview-adding-a-new-mavlink-message/wiki/submitting-patches-back-to-master/"&gt;发送一个pull请求&lt;/a&gt;。如果你发送一个pull提交请求，最好将改变的部分分成至少三个部分的提交确认（commits,与git指令相关，包括pull、push等）。一个是.xml文件的改变提交确认（Setp #3），另一个是重新生成文件的（Step #4），剩下的还有一个或者更多是关于飞行器主代码变化的提交确认。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;链接&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/code-overview-adding-a-new-mavlink-message/"&gt;APM官网原文链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html"&gt;APM开发人员参考手册目录列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;(over)&lt;/em&gt;&lt;/p&gt;</summary><category term="APM"></category><category term="飞控板"></category><category term="硬件"></category></entry><entry><title>APM-规划新代码使之按一定频率运行</title><link href="http://liung.github.io/blog/apm/2014-09-05-APM-ArduCopter%E8%A7%84%E5%88%92%E6%96%B0%E4%BB%A3%E7%A0%81%E4%BD%BF%E4%B9%8B%E6%8C%89%E4%B8%80%E5%AE%9A%E9%A2%91%E7%8E%87%E8%BF%90%E8%A1%8C.html" rel="alternate"></link><updated>2014-09-05T12:08:26+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-09-05:blog/apm/2014-09-05-APM-ArduCopter规划新代码使之按一定频率运行.html</id><summary type="html">&lt;p&gt;本页面将向你介绍如何规划你的新代码块使之可以按需运行。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;用代码调度器运行你的代码&lt;/h3&gt;
&lt;p&gt;在给定时间间隔内来运行你的代码的最灵活的方式就是使用调度器。这可以通过将你的函数添加到文件&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/ArduCopter.pde"&gt;ArduCopter.pde&lt;/a&gt;中的&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/ArduCopter.pde#L788"&gt;&lt;code&gt;scheduler_tasks&lt;/code&gt;&lt;/a&gt;数组来完成。需要表明的是：实际上该文件中有两个任务列表，&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/ArduCopter.pde#L788"&gt;上面的任务列表&lt;/a&gt;是针对高频CPUs（如Pixhawk），&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/ArduCopter.pde#L856"&gt;下面的&lt;/a&gt;是针对低频CPUs（如APM2）。&lt;/p&gt;
&lt;p&gt;添加一个任务是相当的简单，你只要在列表添加新的一行代码就可以了（列表中位置越靠前意味着拥有更高的级别）。任务项中的第一列代表了函数名，第二列是以2.5ms为单位的数字（或者APM2中以10ms为单位）。所以，如果你想要你的函数执行频率为400Hz，那么该列就需要填写为“1”，如果想要50Hz，那么就需要改为“8”。任务项的最后一列代表该函数预计运行花费的微秒（百万分之一秒）时间。这可以帮助调度器来预估在下一个主循环开始之前有否有足够的时间来运行你的函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;  scheduler table - all regular tasks apart from the fast_loop()&lt;/span&gt;
&lt;span class="cm"&gt;  should be listed here, along with how often they should be called&lt;/span&gt;
&lt;span class="cm"&gt;  (in 10ms units) and the maximum time they are expected to take (in&lt;/span&gt;
&lt;span class="cm"&gt;  microseconds)&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;AP_Scheduler&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Task&lt;/span&gt; &lt;span class="n"&gt;scheduler_tasks&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="no"&gt;PROGMEM&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;update_GPS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;            &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="mh"&gt;900&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;update_nav_mode&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;       &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="mh"&gt;400&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;medium_loop&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;           &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="mh"&gt;700&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;update_altitude&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;      &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;    &lt;span class="mh"&gt;1000&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;fifty_hz_loop&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;         &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="mh"&gt;950&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;run_nav_updates&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;      &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="mh"&gt;800&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;slow_loop&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;            &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="mh"&gt;500&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;gcs_check_input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;       &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="mh"&gt;700&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;gcs_send_heartbeat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="mh"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="mh"&gt;700&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;gcs_data_stream_send&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;    &lt;span class="mh"&gt;1500&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;gcs_send_deferred&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;    &lt;span class="mh"&gt;1200&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;compass_accumulate&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;    &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="mh"&gt;700&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;barometer_accumulate&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="mh"&gt;900&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;super_slow_loop&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="mh"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;    &lt;span class="mh"&gt;1100&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;my_new_function&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;      &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="mh"&gt;200&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;  &lt;span class="c1"&gt;//here,添加你的任务项&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;perf_update&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;        &lt;span class="mh"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="mh"&gt;500&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h3&gt;作为循环的一部分运行你的代码&lt;/h3&gt;
&lt;p&gt;为了代替在代码调度器中加入一个新的函数入口，你还可以在现有的任何时间循环事件中添加你的函数。除了在fast-loop循环中添加外，这种方法对比起上面的代码调度器方法并没有什么实质性好处。但当你的代码添加到fast-loop循环中时，就意味着它将以最高的优先级别来执行（它几乎能100%达到所确保的400hz运行速度）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/ArduCopter.pde#L990"&gt;&lt;strong&gt;fast_loop&lt;/strong&gt;&lt;/a&gt;:APM2上运行频率100hz，Pixhawk上400Hz&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/ArduCopter.pde#L1119"&gt;&lt;strong&gt;fifty_hz_loop&lt;/strong&gt;&lt;/a&gt;:运行频率50hz&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/ArduCopter.pde#L1101"&gt;&lt;strong&gt;ten_hz_logging_loop&lt;/strong&gt;&lt;/a&gt;:运行频率10hz&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/ArduCopter.pde#L1138"&gt;&lt;strong&gt;three_hz_loop&lt;/strong&gt;&lt;/a&gt;:运行频率3.3hz&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/ArduCopter.pde#L1159"&gt;&lt;strong&gt;on_hz_loop&lt;/strong&gt;&lt;/a&gt;:运行频率1hz&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以举个例子，如果你想让你的代码运行频率为10hz，那么你就要将它添加到&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/ArduCopter.pde"&gt;ArduCopter.pde&lt;/a&gt;文件的&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/ArduCopter.pde#L1101"&gt;&lt;code&gt;ten_hz_logging_loop()&lt;/code&gt;&lt;/a&gt;函数声明中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// ten_hz_logging_loop&lt;/span&gt;
&lt;span class="c1"&gt;// should be run at 10hz&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;ten_hz_logging_loop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;log_bitmask&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="no"&gt;MASK_LOG_ATTITUDE_MED&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Log_Write_Attitude&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;log_bitmask&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="no"&gt;MASK_LOG_RCIN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;DataFlash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Log_Write_RCIN&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;log_bitmask&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="no"&gt;MASK_LOG_RCOUT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;DataFlash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Log_Write_RCOUT&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;log_bitmask&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="no"&gt;MASK_LOG_NTUN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;mode_requires_GPS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;control_mode&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Log_Write_Nav_Tuning&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="c1"&gt;// 在这里添加你的新代码&lt;/span&gt;
        &lt;span class="n"&gt;my_new_function&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h4&gt;链接&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/code-overview-scheduling-your-new-code-to-run-intermittently/"&gt;APM官网原文链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html"&gt;APM开发人员参考手册目录列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;(over)&lt;/em&gt;&lt;/p&gt;</summary><category term="APM"></category><category term="APM:Copter"></category><category term="飞控板"></category><category term="硬件"></category></entry><entry><title>APM-添加新的飞行模式</title><link href="http://liung.github.io/blog/apm/2014-09-05-APM-ArduCopter%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84%E9%A3%9E%E8%A1%8C%E6%A8%A1%E5%BC%8F.html" rel="alternate"></link><updated>2014-09-05T11:01:10+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-09-05:blog/apm/2014-09-05-APM-ArduCopter添加新的飞行模式.html</id><summary type="html">&lt;p&gt;这部分将涵盖一些怎样创建一个新的高级别的飞行模式的基本操作步骤（类似于自稳，悬停等），这些新模式处于“the onion”（洋葱头工程）中的高级别代码控制部分，如之前&lt;a href="http://liung.github.io/blog/apm/2014-08-31-APM-ArduCopter姿态控制概览.html"&gt;姿态控制页面&lt;/a&gt;描述的一样。不过遗憾的是本页面并没有提供给你关于所创建的理想飞行模式需要的所有信息，但是希望这将是一个好的开始。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Step #1&lt;/strong&gt;：在文件&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/defines.h#L88"&gt;defines.h&lt;/a&gt;中用&lt;code&gt;#define&lt;/code&gt;定义你自己新的飞行模式,然后将飞行模式数量&lt;code&gt;NUM_MODES&lt;/code&gt;加1。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="c1"&gt;// Auto Pilot modes&lt;/span&gt;
    &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;STABILIZE&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;// hold level position&lt;/span&gt;
    &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;ACRO&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;// rate control&lt;/span&gt;
    &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;ALT_HOLD&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="c1"&gt;// AUTO control&lt;/span&gt;
    &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;AUTO&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="c1"&gt;// AUTO control&lt;/span&gt;
    &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;GUIDED&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="c1"&gt;// AUTO control&lt;/span&gt;
    &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;LOITER&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="c1"&gt;// Hold a single location&lt;/span&gt;
    &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;RTL&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="c1"&gt;// AUTO control&lt;/span&gt;
    &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;CIRCLE&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="c1"&gt;// AUTO control&lt;/span&gt;
    &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;LAND&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="c1"&gt;// AUTO control&lt;/span&gt;
    &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;OF_LOITER&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="c1"&gt;// Hold a single location using optical flow sensor&lt;/span&gt;
    &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;DRIFT&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt; &lt;span class="c1"&gt;// DRIFT mode (Note: 12 is no longer used)&lt;/span&gt;
    &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;SPORT&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt; &lt;span class="c1"&gt;// earth frame rate control&lt;/span&gt;
    &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;FLIP&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt; &lt;span class="c1"&gt;// flip the vehicle on the roll axis&lt;/span&gt;
    &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;AUTOTUNE&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt; &lt;span class="c1"&gt;// autotune the vehicle&amp;#39;s roll and pitch gains&lt;/span&gt;
    &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;POSHOLD&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="c1"&gt;// position hold with manual override&lt;/span&gt;

    &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;NEWFLIGHTMODE&lt;/span&gt; &lt;span class="mi"&gt;17&lt;/span&gt;    &lt;span class="c1"&gt;// 描述你所定义的模式内容&lt;/span&gt;
    &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;NUM_MODES&lt;/span&gt; &lt;span class="mi"&gt;18&lt;/span&gt;        &lt;span class="c1"&gt;//模式数+1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Step #2&lt;/strong&gt;：类似于相似的飞行模式的&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/control_stabilize.pde"&gt;control_stabilize.pde&lt;/a&gt;或者&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/control_loiter.pde"&gt;control_loiter.pde&lt;/a&gt;文件，创建新的飞行模式的&lt;code&gt;&amp;lt;new flight mode&amp;gt;.pde&lt;/code&gt;控制sketch文件。该文件中必须包含一个&lt;code&gt;_init()&lt;/code&gt;初始化函数和&lt;code&gt;_run()&lt;/code&gt;运行函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;/// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-&lt;/span&gt;

&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * control_newflightmode.pde - init and run calls for new flight mode&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;

&lt;span class="c1"&gt;// newflightmode_init - initialise flight mode&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;newflightmode_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;ignore_checks&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// do any required initialisation of the flight mode here&lt;/span&gt;
    &lt;span class="c1"&gt;// this code will be called whenever the operator switches into this mode&lt;/span&gt;

    &lt;span class="c1"&gt;// return true initialisation is successful, false if it fails&lt;/span&gt;
    &lt;span class="c1"&gt;// if false is returned here the vehicle will remain in the previous flight mode&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// newflightmode_run - runs the main controller&lt;/span&gt;
&lt;span class="c1"&gt;// will be called at 100hz or more&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;newflightmode_run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// if not armed or throttle at zero, set throttle to zero and exit immediately&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;motors&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;armed&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rc_3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;control_in&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;attitude_control&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;relax_bf_rate_controller&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;attitude_control&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_yaw_target_to_current_heading&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;attitude_control&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_throttle_out&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;false&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// convert pilot input into desired vehicle angles or rotation rates&lt;/span&gt;
    &lt;span class="c1"&gt;//   g.rc_1.control_in : pilots roll input in the range -4500 ~ 4500&lt;/span&gt;
    &lt;span class="c1"&gt;//   g.rc_2.control_in : pilot pitch input in the range -4500 ~ 4500&lt;/span&gt;
    &lt;span class="c1"&gt;//   g.rc_3.control_in : pilot&amp;#39;s throttle input in the range 0 ~ 1000&lt;/span&gt;
    &lt;span class="c1"&gt;//   g.rc_4.control_in : pilot&amp;#39;s yaw input in the range -4500 ~ 4500&lt;/span&gt;

    &lt;span class="c1"&gt;// call one of attitude controller&amp;#39;s attitude control functions like&lt;/span&gt;
    &lt;span class="c1"&gt;//   attitude_control.angle_ef_roll_pitch_rate_yaw(roll angle, pitch angle, yaw rate);&lt;/span&gt;

    &lt;span class="c1"&gt;// call position controller&amp;#39;s z-axis controller or simply pass through throttle&lt;/span&gt;
    &lt;span class="c1"&gt;//   attitude_control.set_throttle_out(desired throttle, true);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Step #3&lt;/strong&gt;：在文件&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/flight_mode.pde#L269"&gt;flight_mode.pde&lt;/a&gt;文件的&lt;code&gt;set_mode()&lt;/code&gt;函数中增加一个新飞行模式的&lt;code&gt;case&lt;/code&gt;（C++中switch..case语法）选项，然后调用上面的&lt;code&gt;_init()&lt;/code&gt;函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// set_mode - change flight mode and perform any necessary initialisation&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;set_mode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// boolean to record if flight mode could be set&lt;/span&gt;
    &lt;span class="n"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;success&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;ignore_checks&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;motors&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;armed&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   &lt;span class="c1"&gt;// allow switching to any mode if disarmed.  We rely on the arming check to perform&lt;/span&gt;

    &lt;span class="c1"&gt;// return immediately if we are already in the desired mode&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;control_mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;switch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;ACRO:&lt;/span&gt;
            &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="no"&gt;FRAME_CONFIG&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="no"&gt;HELI_FRAME&lt;/span&gt;
                &lt;span class="n"&gt;success&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heli_acro_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ignore_checks&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;
                &lt;span class="n"&gt;success&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;acro_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ignore_checks&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="n"&gt;endif&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="c1"&gt;//这里添加case选型：指定飞行模式，然后条用_init()函数&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;NEWFLIGHTMODE:&lt;/span&gt;
            &lt;span class="n"&gt;success&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newflightmode_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ignore_checks&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Step #4&lt;/strong&gt;：在文件&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/flight_mode.pde#L269"&gt;flight_mode.pde&lt;/a&gt;文件的&lt;code&gt;update_flight_mode()&lt;/code&gt;函数中增加一个新飞行模式的&lt;code&gt;case&lt;/code&gt;选项，然后调用上面的&lt;code&gt;_run()&lt;/code&gt;函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// update_flight_mode - calls the appropriate attitude controllers based on flight mode&lt;/span&gt;
&lt;span class="c1"&gt;// called at 100hz or more&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;update_flight_mode&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;control_mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;ACRO:&lt;/span&gt;
            &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="no"&gt;FRAME_CONFIG&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="no"&gt;HELI_FRAME&lt;/span&gt;
                &lt;span class="n"&gt;heli_acro_run&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;
                &lt;span class="n"&gt;acro_run&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="n"&gt;endif&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="c1"&gt;//这里添加case选型：指定飞行模式，然后条用_run()函数&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;NEWFLIGHTMODE:&lt;/span&gt;
            &lt;span class="n"&gt;success&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newflightmode_run&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Step #5&lt;/strong&gt;：在文件&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/flight_mode.pde#L269"&gt;flight_mode.pde&lt;/a&gt;文件的&lt;code&gt;print_flight_mode()&lt;/code&gt;函数中增加可以输出新飞行模式字符串的&lt;code&gt;case&lt;/code&gt;选项。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;print_flight_mode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AP_HAL&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;BetterStream&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;STABILIZE&lt;/span&gt;:
        &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;print_P&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PSTR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;STABILIZE&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//这里增加case选型，执行输出当前飞行模式&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;NEWFLIGHTMODE&lt;/span&gt;:
        &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;print_P&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PSTR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;NEWFLIGHTMODE&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Step #6&lt;/strong&gt;：在文件&lt;a href=""&gt;Parameters.pde&lt;/a&gt;中向&lt;code&gt;FLTMODE1&lt;/code&gt; ~ &lt;code&gt;FLTMODE6&lt;/code&gt;参数中正确的增加你的新飞行模式到&lt;code&gt;@Values&lt;/code&gt;列表中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// @Param: FLTMODE1&lt;/span&gt;
&lt;span class="c1"&gt;// @DisplayName: Flight Mode 1&lt;/span&gt;
&lt;span class="c1"&gt;// @Description: Flight mode when Channel 5 pwm is 1230, &amp;lt;= 1360&lt;/span&gt;
&lt;span class="c1"&gt;// @Values: 0:Stabilize,1:Acro,2:AltHold,3:Auto,4:Guided,5:Loiter,6:RTL,7:Circle,8:Position,9:Land,10:OF_Loiter,11:ToyA,12:ToyM,13:Sport,17:NewFlightMode  //列表末尾添加新的正确形式飞行模式&lt;/span&gt;
&lt;span class="c1"&gt;// @User: Standard&lt;/span&gt;
&lt;span class="no"&gt;GSCALAR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flight_mode1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;FLTMODE1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;               &lt;span class="no"&gt;FLIGHT_MODE_1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;

&lt;span class="c1"&gt;// @Param: FLTMODE2&lt;/span&gt;
&lt;span class="c1"&gt;// @DisplayName: Flight Mode 2&lt;/span&gt;
&lt;span class="c1"&gt;// @Description: Flight mode when Channel 5 pwm is &amp;gt;1230, &amp;lt;= 1360&lt;/span&gt;
&lt;span class="c1"&gt;// @Values: 0:Stabilize,1:Acro,2:AltHold,3:Auto,4:Guided,5:Loiter,6:RTL,7:Circle,8:Position,9:Land,10:OF_Loiter,11:ToyA,12:ToyM,13:Sport,17:NewFlightMode  //列表末尾添加新的正确形式飞行模式&lt;/span&gt;
&lt;span class="c1"&gt;// @User: Standard&lt;/span&gt;
&lt;span class="no"&gt;GSCALAR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flight_mode2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;FLTMODE2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;               &lt;span class="no"&gt;FLIGHT_MODE_2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Step #7&lt;/strong&gt;：如果你想让你的新飞行模式出现的Mission Planner的平视显示器HUD和飞行模式组件中，你可以在&lt;a href="https://github.com/diydrones/MissionPlanner/issues"&gt;Mission Planner的问题列表&lt;/a&gt;中提出你的请求。&lt;/p&gt;
&lt;p&gt;&lt;img alt="MP_HUD" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/08/FlightMode.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;链接&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/apmcopter-adding-a-new-flight-mode/"&gt;APM官网原文链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html"&gt;APM开发人员参考手册目录列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;(over)&lt;/em&gt;&lt;/p&gt;</summary><category term="APM"></category><category term="APM:Copter"></category><category term="飞控板"></category><category term="硬件"></category></entry><entry><title>APM-添加新的参数</title><link href="http://liung.github.io/blog/apm/2014-09-02-APM-%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84%E5%8F%82%E6%95%B0.html" rel="alternate"></link><updated>2014-09-02T14:21:41+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-09-02:blog/apm/2014-09-02-APM-添加新的参数.html</id><summary type="html">&lt;p&gt;我们既可以在主执行代码中添加新的参数，也可以在库中添加。&lt;/p&gt;
&lt;h3&gt;在主执行代码中添加参数&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Step #1&lt;/strong&gt;：在文件&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/Parameters.h"&gt;Parameters.h&lt;/a&gt;参数类中的枚举变量（enum）的合适位置，像下面代码块最后一行一样添加你自己的新的参数。你需要注意下面这些事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽量在执行类似功能的参数区域添加新的参数，或者最坏的情形下就是在“Misc（混合）”区域的末尾添加。&lt;/li&gt;
&lt;li&gt;确保你添加的参数区域中还可以有编号添加新的参数。检查是否能继续添加参数的方法是：检查参数的计数，确保你所要添加的参数的上一个元素编号要小于你的下一部分代码的编号。比如，Misc部分的第一个参数起始于#20,。&lt;code&gt;my_new_parameter&lt;/code&gt;是#36。如果下一部分参数开始于#36，那么我们就不能在这里添加新的参数。&lt;/li&gt;
&lt;li&gt;不要再一个代码块的中间参加新的参数，那样容易造成现存参数对应的信息的改变。&lt;/li&gt;
&lt;li&gt;不要在参数旁边用“弃用（deprecated）”或“移除（remove）”做注解，这是因为一些使用者将此注释用作在eeprom上的旧的参数的默认注解，如果你添加的新参数也是这样注解，那么就让人就会看起来很奇怪和疑惑。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Misc&lt;/span&gt;
    &lt;span class="c1"&gt;//&lt;/span&gt;
    &lt;span class="n"&gt;k_param_log_bitmask&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;k_param_log_last_filenumber&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;            &lt;span class="c1"&gt;// *** Deprecated - remove&lt;/span&gt;
                                            &lt;span class="c1"&gt;// with next eeprom number&lt;/span&gt;
                                            &lt;span class="c1"&gt;// change&lt;/span&gt;
    &lt;span class="n"&gt;k_param_toy_yaw_rate&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;                           &lt;span class="c1"&gt;// THOR The memory&lt;/span&gt;
                                                    &lt;span class="c1"&gt;// location for the&lt;/span&gt;
                                                    &lt;span class="c1"&gt;// Yaw Rate 1 = fast,&lt;/span&gt;
                                                    &lt;span class="c1"&gt;// 2 = med, 3 = slow&lt;/span&gt;

    &lt;span class="n"&gt;k_param_crosstrack_min_distance&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;    &lt;span class="c1"&gt;// deprecated - remove with next eeprom number change&lt;/span&gt;
    &lt;span class="n"&gt;k_param_rssi_pin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;k_param_throttle_accel_enabled&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="c1"&gt;// deprecated - remove&lt;/span&gt;
    &lt;span class="n"&gt;k_param_wp_yaw_behavior&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;k_param_acro_trainer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;k_param_pilot_velocity_z_max&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;k_param_circle_rate&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;k_param_sonar_gain&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;k_param_ch8_option&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;k_param_arming_check_enabled&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;k_param_sprayer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;k_param_angle_max&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;k_param_gps_hdop_good&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;          &lt;span class="c1"&gt;// 35&lt;/span&gt;

    &lt;span class="n"&gt;k_param_my_new_parameter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;       &lt;span class="c1"&gt;// 36（这里添加你的新的参数）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Step #2&lt;/strong&gt;：在枚举变量后面的参数类中声明这些变量。可使用的类型包括&lt;code&gt;AP_Int8&lt;/code&gt;,&lt;code&gt;AP_Int16&lt;/code&gt;,&lt;code&gt;AP_Float&lt;/code&gt;,&lt;code&gt;AP_Int32&lt;/code&gt;,&lt;code&gt;AP_Vector3&lt;/code&gt;(目前还不支持&lt;code&gt;unsigned integer&lt;/code&gt;无符号整型)。新的枚举变量的名称应该保持一致，只是去掉了前缀&lt;code&gt;k_param_&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// 254,255: reserved&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;AP_Int16&lt;/span&gt;        &lt;span class="n"&gt;format_version&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;AP_Int8&lt;/span&gt;         &lt;span class="n"&gt;software_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Telemetry control&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="n"&gt;AP_Int16&lt;/span&gt;        &lt;span class="n"&gt;sysid_this_mav&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;AP_Int16&lt;/span&gt;        &lt;span class="n"&gt;sysid_my_gcs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;AP_Int8&lt;/span&gt;         &lt;span class="n"&gt;serial3_baud&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;AP_Int8&lt;/span&gt;         &lt;span class="n"&gt;telem_delay&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;AP_Int16&lt;/span&gt;        &lt;span class="n"&gt;rtl_altitude&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;AP_Int8&lt;/span&gt;         &lt;span class="n"&gt;sonar_enabled&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;AP_Int8&lt;/span&gt;         &lt;span class="n"&gt;sonar_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 0 = XL, 1 = LV,&lt;/span&gt;
                                  &lt;span class="c1"&gt;// 2 = XLL (XL with 10m range)&lt;/span&gt;
                                  &lt;span class="c1"&gt;// 3 = HRLV&lt;/span&gt;
&lt;span class="n"&gt;AP_Float&lt;/span&gt;        &lt;span class="n"&gt;sonar_gain&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;AP_Int8&lt;/span&gt;         &lt;span class="n"&gt;battery_monitoring&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// 0=disabled, 3=voltage only,&lt;/span&gt;
                                            &lt;span class="c1"&gt;// 4=voltage and current&lt;/span&gt;
&lt;span class="n"&gt;AP_Float&lt;/span&gt;        &lt;span class="n"&gt;volt_div_ratio&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;AP_Float&lt;/span&gt;        &lt;span class="n"&gt;curr_amp_per_volt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;AP_Int16&lt;/span&gt;        &lt;span class="n"&gt;pack_capacity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// Battery pack capacity less reserve&lt;/span&gt;
&lt;span class="n"&gt;AP_Int8&lt;/span&gt;         &lt;span class="n"&gt;failsafe_battery_enabled&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// battery failsafe enabled&lt;/span&gt;
&lt;span class="n"&gt;AP_Int8&lt;/span&gt;         &lt;span class="n"&gt;failsafe_gps_enabled&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// gps failsafe enabled&lt;/span&gt;
&lt;span class="n"&gt;AP_Int8&lt;/span&gt;         &lt;span class="n"&gt;failsafe_gcs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// ground station failsafe behavior&lt;/span&gt;
&lt;span class="n"&gt;AP_Int16&lt;/span&gt;        &lt;span class="n"&gt;gps_hdop_good&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// GPS Hdop value below which represent a good position&lt;/span&gt;

&lt;span class="n"&gt;AP_Int16&lt;/span&gt;        &lt;span class="n"&gt;my_new_parameter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// my new parameter&amp;#39;s description goes here（新添加的参数的注解）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Step #3&lt;/strong&gt;：在&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/Parameters.pde"&gt;Parameters.pde&lt;/a&gt;文件中向var_info表中添加变量的声明信息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// @Param: MY_NEW_PARAMETER&lt;/span&gt;
&lt;span class="c1"&gt;// @DisplayName: My New Parameter&lt;/span&gt;
&lt;span class="c1"&gt;// @Description: A description of my new parameter goes here&lt;/span&gt;
&lt;span class="c1"&gt;// @Range: -32768 32767&lt;/span&gt;
&lt;span class="c1"&gt;// @User: Advanced&lt;/span&gt;
&lt;span class="no"&gt;GSCALAR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;my_new_parameter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;MY_NEW_PARAMETER&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;MY_NEW_PARAMETER_DEFAULT&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;地面站（如Mission Planner）中将使用&lt;code&gt;@Param ~ @User&lt;/code&gt;的注释信息向使用者说明用户所设置的变量的范围等。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Step #4&lt;/strong&gt;:在&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/config.h"&gt;config.h&lt;/a&gt;中添加你的新参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#ifndef MY_NEW_PARAMETER_DEFAULT&lt;/span&gt;
 &lt;span class="c"&gt;# define MY_NEW_PARAMETER_DEFAULT      100     // default value for my new parameter&lt;/span&gt;
&lt;span class="c"&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;向主执行代码添加参数的工作就完成了！添加到主代码中(并非库中)的参数就可以通过诸如&lt;code&gt;g.my_new_parameter&lt;/code&gt;这样来使用。&lt;/p&gt;
&lt;h3&gt;向库中添加参数&lt;/h3&gt;
&lt;p&gt;同样可以使用下列步骤向库中添加新的参数。以&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_Compass"&gt;AP_Compass&lt;/a&gt;库为例：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Step #1&lt;/strong&gt;：首先在库代码的.h头文件添加新的变量(如&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_Compass"&gt;Compass.h&lt;/a&gt;)。可使用的类型包括&lt;code&gt;AP_Int8&lt;/code&gt;,&lt;code&gt;AP_Int16&lt;/code&gt;,&lt;code&gt;AP_Float&lt;/code&gt;,&lt;code&gt;AP_Int32&lt;/code&gt;,&lt;code&gt;AP_Vector3f&lt;/code&gt;。然后添加你的参数的默认值（我们将在Step #2中使用）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#define MY_NEW_PARAM_DEFAULT         100    &lt;/span&gt;&lt;span class="c1"&gt;///在此处声明变量和默认值&lt;/span&gt;

&lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Compass&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;
    &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="n"&gt;product_id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                         &lt;span class="c1"&gt;/// product id&lt;/span&gt;
    &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="n"&gt;mag_x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                      &lt;span class="c1"&gt;///&amp;lt; magnetic field strength along the X axis&lt;/span&gt;
    &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="n"&gt;mag_y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                      &lt;span class="c1"&gt;///&amp;lt; magnetic field strength along the Y axis&lt;/span&gt;
    &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="n"&gt;mag_z&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                      &lt;span class="c1"&gt;///&amp;lt; magnetic field strength along the Z axis&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;last_update&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;///&amp;lt; micros() time of last update&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;healthy&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                               &lt;span class="c1"&gt;///&amp;lt; true if last read OK&lt;/span&gt;

    &lt;span class="c1"&gt;/// Constructor&lt;/span&gt;
    &lt;span class="c1"&gt;///&lt;/span&gt;
    &lt;span class="n"&gt;Compass&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="nl"&gt;protected:&lt;/span&gt;
    &lt;span class="n"&gt;AP_Int8&lt;/span&gt; &lt;span class="n"&gt;_orientation&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;AP_Vector3f&lt;/span&gt; &lt;span class="n"&gt;_offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;AP_Float&lt;/span&gt; &lt;span class="n"&gt;_declination&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;AP_Int8&lt;/span&gt; &lt;span class="n"&gt;_use_for_yaw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                       &lt;span class="c1"&gt;///&amp;lt;enable use for yaw calculation&lt;/span&gt;
    &lt;span class="n"&gt;AP_Int8&lt;/span&gt; &lt;span class="n"&gt;_auto_declination&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;///&amp;lt;enable automatic declination code&lt;/span&gt;

    &lt;span class="n"&gt;AP_Int16&lt;/span&gt; &lt;span class="n"&gt;_my_new_lib_parameter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;/// description of my new parameter（你的变量的注解）&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Step #2&lt;/strong&gt;：然后在.cpp文件（如&lt;a href="https://github.com/diydrones/ardupilot/blob/master/libraries/AP_Compass/Compass.cpp"&gt;Compass.cpp&lt;/a&gt;）中添加变量包含有&lt;code&gt;@Param ~ @Increment&lt;/code&gt;的var_info表信息，以便允许GCS向用户显示来自地面站的关于该参数值的范围设定。当添加新参数时应注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自己添加的代码编号（下面的编号9）一定要比之前变量的大。&lt;/li&gt;
&lt;li&gt;参数的名称（如&lt;code&gt;MY_NEW_P&lt;/code&gt;）包括对象自动添加的前缀要少于16个字符。比如罗盘对象的前缀为“&lt;code&gt;COMPASS_&lt;/code&gt;”。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;AP_Param&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nl"&gt;GroupInfo&lt;/span&gt; &lt;span class="nx"&gt;Compass&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nl"&gt;var_info&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; PROGMEM = {
    // index 0 was used for the old orientation matrix

    // @Param: OFS_X
    // @DisplayName: Compass offsets on the X axis
    // @Description: Offset to be added to the compass x-axis values to compensate for metal in the frame
    // @Range: -400 400
    // @Increment: 1

&lt;span class="nt"&gt;&amp;lt;snip&amp;gt;&lt;/span&gt;

    // @Param: ORIENT
    // @DisplayName: Compass orientation
    // @Description: The orientation of the compass relative to the autopilot board.
    // @Values: 0:None,1:Yaw45,2:Yaw90,3:Yaw135,4:Yaw180,5:Yaw225,6:Yaw270,7:Yaw315,8:Roll180
    AP_GROUPINFO(&amp;quot;ORIENT&amp;quot;, 8, Compass, _orientation, ROTATION_NONE),

    //你添加的代码区域
    // @Param: MY_NEW_P
    // @DisplayName: My New Library Parameter
    // @Description: The new library parameter description goes here
    // @Range: -32768 32767
    // @User: Advanced
    AP_GROUPINFO(&amp;quot;MY_NEW_P&amp;quot;, 9, Compass, _my_new_lib_parameter, MY_NEW_PARAM_DEFAULT),
    //以上为你添加的代码区域

    AP_GROUPEND
};
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样，新添加的参数将以&lt;code&gt;_my_new_lib_parameter&lt;/code&gt;包含在库中。需要指明的是：&lt;code&gt;protected&lt;/code&gt;保护类型的参数是不能够在类外被访问的。如果我们将其变为&lt;code&gt;public&lt;/code&gt;类型，那么我们就可以在主代码中使用&lt;code&gt;compass._my_new_lib_parameter&lt;/code&gt;参数了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;链接&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/code-overview-adding-a-new-parameter/"&gt;APM官网原文链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html"&gt;APM开发人员参考手册目录列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;(over)&lt;/em&gt;&lt;/p&gt;</summary><category term="APM"></category><category term="APM:Copter"></category><category term="飞控板"></category><category term="硬件"></category></entry><entry><title>APM-ArduCopter姿态控制概览</title><link href="http://liung.github.io/blog/apm/2014-08-31-APM-ArduCopter%E5%A7%BF%E6%80%81%E6%8E%A7%E5%88%B6%E6%A6%82%E8%A7%88.html" rel="alternate"></link><updated>2014-08-31T21:53:09+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-08-31:blog/apm/2014-08-31-APM-ArduCopter姿态控制概览.html</id><summary type="html">

&lt;p&gt;在从版本AC3.1向AC3.2的过渡中，姿态控制逻辑运算作为“the onion”（洋葱头）工程的一部分进行了重构。下面来展示重构后的程序执行流程。
&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;手动飞行模式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;自稳模式（Stabilize Mode）、特技模式（Acro Mode）、浮动模式（Drift Mode）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="flight-mode" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/06/AC_CodeOverview_ManualFlightMode.png" /&gt;&lt;/p&gt;
&lt;p&gt;在主循环执行过程中（比如Pixhawk的运行频率为400Hz，APM2.x为100Hz），系统依次执行如下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;调用最高层次级别文件flight-mode.pde中的&lt;code&gt;update_flight_mode()&lt;/code&gt;函数。该函数监测当前飞行器的飞行模式（使用变量&lt;code&gt;control_mode&lt;/code&gt;），然后执行相应飞行模式下的&lt;code&gt;&amp;lt;flight mode&amp;gt;_run()&lt;/code&gt;函数（如自稳模式的&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/control_stabilize.pde#L20"&gt;&lt;code&gt;stabilize_run&lt;/code&gt;&lt;/a&gt;，返航模式（RTL）的&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/control_rtl.pde#L23"&gt;&lt;code&gt;rtl_run&lt;/code&gt;&lt;/a&gt;等）。执行&lt;code&gt;&amp;lt;flight mode&amp;gt;_run&lt;/code&gt;的结果是，系统将会找到与飞行模式相对应的命名为&lt;code&gt;control_&amp;lt;flight mode&amp;gt;.pde&lt;/code&gt;飞行控制文件（比如：&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/control_stabilize.pde"&gt;&lt;code&gt;control_stabilize.pde&lt;/code&gt;&lt;/a&gt;，&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/control_rtl.pde"&gt;&lt;code&gt;control_rtl.pde&lt;/code&gt;&lt;/a&gt;等）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;flight mode&amp;gt;_run&lt;/code&gt;函数负责将用户的输入（从&lt;code&gt;g.rc_1.control_in&lt;/code&gt;，&lt;code&gt;g.rc_2.control_in&lt;/code&gt;等读入）转换为此时飞行模式下的倾斜角（lean angle）、滚转速率（rotation rate）、爬升率（climb rate）等。举个例子：&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/control_althold.pde#L22"&gt;AltHold&lt;/a&gt;(定高，altitude hold)模式中将用户的滚转和俯仰输入转换为倾斜角（单位：角度/°），将偏航输入转换为滚转速率（单位：°/s），将油门输入转换为爬升率（单位：cm/s）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;flight mode&amp;gt;_run&lt;/code&gt;函数最后还必须要完成的就是将&lt;strong&gt;预期角度、速率等参数&lt;/strong&gt;传送给姿态控制和/或方位控制库（它们都放在&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AC_AttitudeControl"&gt;AC_AttitiudeControl&lt;/a&gt;文件夹内）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AC_AttitudeControl"&gt;AC_AttitiudeControl&lt;/a&gt;库提供了5中可能的方法来调整飞行器的姿态，下面来说明最通用的三种方法：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;------&amp;gt;1) &lt;a href="https://github.com/diydrones/ardupilot/blob/master/libraries/AC_AttitudeControl/AC_AttitudeControl.h#L98"&gt;&lt;code&gt;angle_ef_roll_pitch_rate_ef_yaw()&lt;/code&gt;&lt;/a&gt;:该函数需要一个地轴系坐标下滚转和偏航角度，一个地轴系坐标下的偏航速率。例如：传递给该函数三个参数分别为，&lt;code&gt;roll = -1000， pitch = -1500， yaw = 500&lt;/code&gt;代表飞行器此时向左倾斜10°，低头15°，向右偏航速率为5°/s。&lt;/p&gt;
&lt;p&gt;------&amp;gt;2) &lt;a href="https://github.com/diydrones/ardupilot/blob/master/libraries/AC_AttitudeControl/AC_AttitudeControl.h#L102"&gt;&lt;code&gt;angle_ef_roll_pitch_yaw()&lt;/code&gt;&lt;/a&gt;:该函数接受地轴系下的滚转、俯仰和偏航角。和上面的函数类似，不过参数&lt;code&gt;yaw = 500&lt;/code&gt;代表飞行器北偏东5°&lt;/p&gt;
&lt;p&gt;------&amp;gt;3) &lt;a href="https://github.com/diydrones/ardupilot/blob/master/libraries/AC_AttitudeControl/AC_AttitudeControl.h#L108"&gt;&lt;code&gt;rate_bf_roll_pitch_yaw()&lt;/code&gt;&lt;/a&gt;:该函数接受一个&lt;strong&gt;体轴系&lt;/strong&gt;下的滚转、俯仰和偏航角速率（°/s）。例如：传递给该函数三个参数：&lt;code&gt;roll = -1000， pitch = -1500， yaw = 500&lt;/code&gt;代表飞行器此时左倾速率10°/s，低头速率15°/s，绕Z轴速率为5°/s。&lt;/p&gt;
&lt;p&gt;当上述这些函数调用之后，就会接着调用&lt;a href="https://github.com/diydrones/ardupilot/blob/master/libraries/AC_AttitudeControl/AC_AttitudeControl.h#L114"&gt;&lt;code&gt;AC_AttitudeControl::rate_controller_run()&lt;/code&gt;&lt;/a&gt;函数，将上面所列举的函数的输出转化为滚转、偏航和俯仰输入，并使用&lt;a href="https://github.com/diydrones/ardupilot/blob/master/libraries/AP_Motors/AP_Motors_Class.h#L99"&gt;&lt;code&gt;set_roll,set_pitch,set_yaw&lt;/code&gt; 和 &lt;code&gt;set_throttle&lt;/code&gt;&lt;/a&gt;方法将这些输入发送给&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_Motors"&gt;&lt;strong&gt;AP_Motors&lt;/strong&gt;&lt;/a&gt;库。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/blob/master/libraries/AC_AttitudeControl/AC_PosControl.h"&gt;AC_PosControl&lt;/a&gt;库用来控制飞行器的3D方位。不过通常只用来调整比较简单的Z轴方向（如姿态控制），这是因为许多需要复杂3D方位调整的飞行模式(例如&lt;a href="https://github.com/diydrones/ardupilot/blob/master/ArduCopter/control_loiter.pde#L30"&gt;悬停Loiter&lt;/a&gt;)使用的是&lt;a href="https://github.com/diydrones/ardupilot/blob/master/libraries/AC_WPNav/AC_WPNav.h"&gt;AC_WPNav&lt;/a&gt;库。总之，AC_PosControl库中常用的方法有：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;------&amp;gt;1) &lt;code&gt;set_alt_target_from_climb_rate()&lt;/code&gt;:将爬升率（cm/s）作为参数，用来更新一个需要调整的相对高度目标。&lt;/p&gt;
&lt;p&gt;------&amp;gt;2)  &lt;code&gt;set_pos_target()&lt;/code&gt;:接受一个以系统中的&lt;code&gt;home&lt;/code&gt;位置作为参考点的3D位置矢量（单位：cm）。&lt;/p&gt;
&lt;p&gt;如果调用了AC_PosControl中的任何一个方法，那么在该飞行模式下就必须调用函数&lt;a href="https://github.com/diydrones/ardupilot/blob/master/libraries/AC_AttitudeControl/AC_PosControl.h#L134"&gt;&lt;code&gt;AC_PosControl::update_z_controller()&lt;/code&gt;&lt;/a&gt;。这样的话，就可以启用Z轴的方位控制PID循环，并向&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_Motors"&gt;&lt;strong&gt;AP_Motors&lt;/strong&gt;&lt;/a&gt;库发送低级别的油门信息。同样，如果调用了xy轴的函数，那就就必须调用&lt;a href="https://github.com/diydrones/ardupilot/blob/master/libraries/AC_AttitudeControl/AC_PosControl.h#L202"&gt;&lt;code&gt;AC_PosControl::update_xy_controller()&lt;/code&gt;&lt;/a&gt;函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AP_Motors&lt;/strong&gt;库含有“电机混合模式”代码。这些代码负责将从&lt;strong&gt;AC_AttitudeControl&lt;/strong&gt;和&lt;strong&gt;AC_PosControl&lt;/strong&gt;库发送过来的滚转、俯仰、偏航角度和油门值信息转换为电机的相对输出值（例如：PWM值）。因此，这样高级别的库就必须要使用如下函数：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;------&amp;gt;1) &lt;a href="https://github.com/diydrones/ardupilot/blob/master/libraries/AP_Motors/AP_Motors_Class.h#L99"&gt;&lt;code&gt;set_roll(),set_pitch(),set_yaw()&lt;/code&gt;&lt;/a&gt;：接受在[-4500,4500]角度范围内的滚转、俯仰和偏航角。这些参数不是期望角度或者速率，更准确的讲，它仅仅是一个数值。例如，set_roll(-4500)将代表飞行器尽可能快的向左滚转。&lt;/p&gt;
&lt;p&gt;------&amp;gt;2) &lt;code&gt;set_throttle()&lt;/code&gt;:接受一个范围在[0,1000]的相对油门值。0代表电机关闭，1000代表满油门状态。&lt;/p&gt;
&lt;p&gt;虽然对于不同飞行器构型（如四旋翼，Y6，传统直升机等）的控制代码中有许多不同的类，但这些类中都有一个相同的函数&lt;code&gt;output_armed&lt;/code&gt;，负责将这些滚转、俯仰、偏航和油门值转换为PWM类型输入值。这转换的过程中，会应用到&lt;strong&gt;stability patch&lt;/strong&gt;（译者注：翻译成中文感觉不妥，类似于控制飞行器稳定性分析程序代码块），用来控制由于飞行器构型限制所引起的轴系的优先级问题（例如四旋翼的四个电机不可能在做最大速度滚转时四个电机的油门同时达到最大，因为必须一部分电机输出小于另一部分才能引起滚转）。在执行函数&lt;code&gt;output_armed&lt;/code&gt;的最后，还将调用&lt;code&gt;hal.rcout-&amp;gt;write()&lt;/code&gt;，把期望PWM值传递给&lt;strong&gt;AP_HAL&lt;/strong&gt;层。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AP_HAL库（硬件抽象层）提供了针对所有飞控板统一的借口。实际控制中，&lt;code&gt;hal.rc_out_write()&lt;/code&gt;函数将接受到的来自于AP_Motors类中指定的PWM值，输出至飞控板对应的PWM端口（pin端）。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4&gt;链接&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/apmcopter-programming-attitude-control-2/"&gt;APM官网原文链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html"&gt;APM开发人员参考手册目录列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;(over)&lt;/em&gt;&lt;/p&gt;</summary><category term="APM"></category><category term="飞控板"></category><category term="硬件"></category></entry><entry><title>IPython学习笔记</title><link href="http://liung.github.io/blog/python/2014-08-31-IPython%E5%91%BD%E4%BB%A4%E9%9B%86.html" rel="alternate"></link><updated>2014-08-31T10:55:41+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-08-31:blog/python/2014-08-31-IPython命令集.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ipython --pylab=inline:&lt;/strong&gt;ipython启动后默认导入numpy和matplotlib.pylab模块&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ipython qtconsole&lt;/strong&gt;:使用Qt Gui 后台&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;%lsmagic：&lt;/strong&gt;列出ipython中的所有魔法命令&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; %whos:&lt;/strong&gt; 查看变量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;%reset:&lt;/strong&gt; 清空变量，包括np和pylab模块&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;%pylab：&lt;/strong&gt;重新导入numpy和pylab模块&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;%bookmark alias：&lt;/strong&gt;将当前目录用alias作为标签，cd alias可以直接进入该目录&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;%run script.py&lt;/strong&gt; 执行脚本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;%edit script.py&lt;/strong&gt; 编辑器中编辑脚本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;%hist：&lt;/strong&gt;输入之前的输入历史&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;_：&lt;/strong&gt;下划线表示暂存的上次返回变量（grab previous result）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ipython采用tab自动补全功能&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;ipython继承Unix风格命令&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;%ls&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;%cd&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;%pwd&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Available line magics&lt;/h4&gt;
&lt;p&gt;%alias  %alias_magic  %autocall  %automagic  %autosave  %bookmark  %cd  %clear  %cls  %colors  %config  %connect_info  %debug  %dhist  %dirs  %doctest_mode  %ed  %edit  %env  %gui  %guiref  %hist  %history  %install_default_config  %install_ext  %install_profiles  %killbgscripts  %less  %load  %load_ext  %loadpy  %logoff  %logon  %logstart  %logstate  %logstop  %lsmagic  %macro  %magic  %matplotlib  %more  %notebook  %page  %pastebin  %pdb  %pdef  %pdoc  %pfile  %pinfo  %pinfo2  %popd  %pprint  %precision  %profile  %prun  %psearch  %psource  %pushd  %pwd  %pycat  %pylab  %qtconsole  %quickref  %recall  %rehashx  %reload_ext  %rep  %rerun  %reset  %reset_selective  %run  %save  %sc  %store  %sx  %system  %tb  %time  %timeit  %unalias  %unload_ext  %who  %who_ls  %whos  %xdel  %xmode&lt;/p&gt;
&lt;h4&gt;Available cell magics&lt;/h4&gt;
&lt;p&gt;%%!  %%HTML  %%SVG  %%bash  %%capture  %%cmd  %%debug  %%file  %%html  %%javascript  %%latex  %%perl  %%powershell  %%prun  %%pypy  %%python  %%python3  %%ruby  %%script  %%sh  %%svg  %%sx  %%system  %%time  %%timeit  %%writefile&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Automagic is ON, % prefix IS NOT needed for line magics.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;IPython标准键盘快捷键&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ctrl+P或上箭头&lt;/strong&gt;：后向搜索命令历史中以当前输入的文本开头的命令&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl+N或下箭头&lt;/strong&gt;：前向搜索命令历史中以当前输入的文本开头的命令&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl+R&lt;/strong&gt;：执行读取的反向历史搜索（部分搜索）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl+Shift+V&lt;/strong&gt;：从剪切板粘贴文本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl+C&lt;/strong&gt;：终止当前正在执行的代码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl+A&lt;/strong&gt;：将光标移至行首&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl+E&lt;/strong&gt;：将光标移至行尾&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl+K&lt;/strong&gt;：删除从光标开始至行尾的文本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl+U&lt;/strong&gt;：删除当前行的所有文本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl+F&lt;/strong&gt;：将光标向前移动一个字符&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl+B&lt;/strong&gt;：将光标向后移动一个字符&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl+L&lt;/strong&gt;：清屏&lt;/li&gt;
&lt;/ul&gt;</summary><category term="python"></category><category term="ipython"></category></entry><entry><title>APM:Copter相关库</title><link href="http://liung.github.io/blog/apm/2014-08-30-APM-Arducopter%E7%9B%B8%E5%85%B3%E5%BA%93%E4%BB%8B%E7%BB%8D.html" rel="alternate"></link><updated>2014-08-30T15:53:36+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-08-30:blog/apm/2014-08-30-APM-Arducopter相关库介绍.html</id><summary type="html">&lt;p&gt;这些&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries"&gt;库文件&lt;/a&gt;也同样被ArduPlane和ArduRover所使用。下面将列出一系列高层次的库的说明和它们的函数说明。&lt;/p&gt;
&lt;h3&gt;核心库&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_AHRS"&gt;AP_AHRS&lt;/a&gt;：采用DCM（方向余弦矩阵方法）或EKF（扩展卡尔曼滤波方法）预估飞行器姿态&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_InertialNav"&gt;AP_Common&lt;/a&gt;：所有执行文件（sketch格式，arduino IDE的文件）和其他库都需要的基础核心库。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_Math"&gt;AP_Math&lt;/a&gt;：包含了许多数学函数，特别对于矢量运算&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AC_PID"&gt;AP_PID&lt;/a&gt;：PID控制器库&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_InertialNav"&gt;AP_InertialNav&lt;/a&gt;：扩展带有gps和气压计数据的惯性导航库&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AC_AttitudeControl"&gt;AP_AttitudeControl&lt;/a&gt;：姿态控制相关库&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_InertialNav"&gt;AP_WPNav&lt;/a&gt;：航点相关的导航库&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_Motors"&gt;AP_Motors&lt;/a&gt;：多旋翼和传统直升机混合的电机库&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/RC_Channel"&gt;RC_channel&lt;/a&gt;：更多的关于从APM_RC的PWM输入/输出数据转换到内部通用单位的库，比如角度&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_HAL"&gt;AP_HAL&lt;/a&gt;，&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_HAL_AVR"&gt;AP_HAL_AVR&lt;/a&gt;，&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_HAL_PX4"&gt;AP_HAL_PX4&lt;/a&gt;:硬件抽象层库，提供给其他高级控制代码一致的接口，而不必担心底层不同的硬件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;传感器相关库&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_InertialSensor"&gt;AP_InertialSensor&lt;/a&gt;：读取陀螺仪和加速度计数据，并向主程序执行标准程序和提供标准单位数据（deg/s，m/s）。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_RangeFinder"&gt;AP_RangerFinder&lt;/a&gt;：声呐和红外测距传感器的交互库&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_Baro"&gt;AP_Baro&lt;/a&gt;：气压计相关库&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_GPS"&gt;AP_GPS&lt;/a&gt;：GPS相关库&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_Compass"&gt;AP_Compass&lt;/a&gt;：三轴罗盘相关库&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_OpticalFlow"&gt;AP_OpticalFlow&lt;/a&gt;：光流传感器相关库&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;其他库&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_Mount"&gt;AP_Mount&lt;/a&gt;，&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_Camera"&gt;AP_Camera&lt;/a&gt;, &lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_Relay"&gt;AP_Relay&lt;/a&gt;：相机安装控制库，相机快门控制库&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_Mission"&gt;AP_Mission&lt;/a&gt;： 从eeprom（电可擦只读存储器）存储/读取飞行指令相关库&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries/AP_Buffer"&gt;AP_Buffer&lt;/a&gt;：惯性导航时所用到的一个简单的堆栈（FIFO，先进先出）缓冲区&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是本人做的一张关于库的导航图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="daohang" src="http://liung.github.io/images/apm-libraries.png" /&gt;&lt;/p&gt;
&lt;h4&gt;链接&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/apmcopter-programming-libraries/"&gt;APM官网原文链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html"&gt;APM开发人员参考手册目录列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;(over)&lt;/em&gt;&lt;/p&gt;</summary><category term="APM:Copter"></category><category term="APM"></category><category term="硬件"></category><category term="C++"></category></entry><entry><title>APM:Copter 代码预览</title><link href="http://liung.github.io/blog/apm/2014-08-30-APM-Arducopter%E4%BB%A3%E7%A0%81%E9%A2%84%E8%A7%88.html" rel="alternate"></link><updated>2014-08-30T15:29:29+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-08-30:blog/apm/2014-08-30-APM-Arducopter代码预览.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/diydrones/ardupilot"&gt;&lt;strong&gt;APM::Copter&lt;/strong&gt;&lt;/a&gt;代码主要放在ArduCopter文件夹中，并且和&lt;strong&gt;ArduPlane&lt;/strong&gt;和&lt;strong&gt;ArduRover&lt;/strong&gt;使用同样的&lt;a href="https://github.com/diydrones/ardupilot/tree/master/libraries"&gt;库文件&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面这张图展示了从飞行模式到电机输出的高级别代码概要：&lt;/p&gt;
&lt;h2&gt;&lt;img alt="file-mode" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/06/AC_CodeOverview_AutoFlightModes.png" /&gt;&lt;/h2&gt;
&lt;h3&gt;主要组成部分&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-30-APM-Arducopter相关库介绍.html"&gt;库说明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-31-APM-ArduCopter姿态控制概览.html"&gt;姿态控制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-09-02-APM-添加新的参数.html"&gt;如何添加参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-09-05-APM-ArduCopter添加新的飞行模式.html"&gt;如何创建新的飞行模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-09-05-APM-ArduCopter规划新代码使之按一定频率运行.html"&gt;如何让你的新代码按一定频率执行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-09-05-APM-增加新的MAVLink通讯协议消息.html"&gt;如何增加新的MAVLink协议信息&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h4&gt;链接&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/apmcopter-code-overview/"&gt;APM官网原文链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html"&gt;APM开发人员参考手册目录列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;(over)&lt;/em&gt;&lt;/p&gt;</summary><category term="APM"></category><category term="APM:Copter"></category><category term="飞控板"></category><category term="硬件"></category></entry><entry><title>APM-如何获取源码</title><link href="http://liung.github.io/blog/apm/2014-08-29-APM-%E8%8E%B7%E5%8F%96%E6%BA%90%E7%A0%81.html" rel="alternate"></link><updated>2014-08-29T22:11:41+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-08-29:blog/apm/2014-08-29-APM-获取源码.html</id><summary type="html">&lt;p&gt;整个APM工程的源码都采用&lt;a href="http://git-scm.com/"&gt;git&lt;/a&gt;（译者注：一款自由和开源的分布式版本控制系统）进行代码管理，并且托管在&lt;a href="https://github.com/"&gt;github&lt;/a&gt;网站上。&lt;/p&gt;
&lt;p&gt;目前APM的源码以开源的形式托管在&lt;a href="https://github.com/diydrones/ardupilot"&gt;https://github.com/diydrones/ardupilot&lt;/a&gt;上。由于历史原因，另一个老版本的Google code仓库仍然保持在线可访问状态，但是除非你对老版本（APM 1.x）有特殊的需求，一般建议您不要使用该仓库中的代码。&lt;/p&gt;
&lt;p&gt;固定翼飞机（Plane），旋翼飞行器（Copter），无人车（Rover）模块全部包含在&lt;a href="https://github.com/diydrones/ardupilot"&gt; diydrones/ardupilot &lt;/a&gt;代码库中，天线跟踪模块虽然也包含在该代码库中，但在文件目录&lt;code&gt;Tools/&lt;/code&gt;下。&lt;/p&gt;
&lt;p&gt;地面站MissionPlanner包含在&lt;a href="https://github.com/diydrones/MissionPlanner"&gt;diydrones/MissionPlanner&lt;/a&gt;代码库中。&lt;/p&gt;
&lt;h3&gt;预备知识&lt;/h3&gt;
&lt;p&gt;Git在绝大多数操作平台上都是可以使用的，并且还存在各种工具使得开始使用Git更加简单。首先，你需要&lt;a href="http://git-scm.com/downloads"&gt;下载和安装对应你使用的操作平台的客户端程序&lt;/a&gt;，如果你刚开始接触到这种源代码控制系统，那么，&lt;a href="https://windows.github.com/"&gt;windows版的GitHub&lt;/a&gt;或&lt;a href="https://mac.github.com/"&gt;Mac版的GitHub&lt;/a&gt;客户端都有一个非常好的使用文档，并且和GitHub有着很好的集成，可以从这里开始学习如何使用Git。本次说明将同时使用Windows版的Github用户界面和OSX/Linux终端下的命令行界面进行操作。&lt;/p&gt;
&lt;p&gt;如果你想要直接向APM官网代码库中提交代码，那么你需要&lt;a href="https://github.com/join"&gt;在Github上免费注册一个账号&lt;/a&gt;。&lt;/p&gt;
&lt;h4&gt;学习Git&lt;/h4&gt;
&lt;p&gt;本次操作将用到一些基本的git指令：clone，branch，commit，push。你没必要为了本次操作而必须很精通Git。除了本手册之外还有许多关于使用git的教程，当中有许多资源是在线形式的。这里有一些对你可能有用的资源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://try.github.io/levels/1/challenges/1"&gt;Try Git&lt;/a&gt;：基于浏览器交互学习的学习Git教程&lt;/li&gt;
&lt;li&gt;&lt;a href="http://gitready.com/"&gt;Git Ready&lt;/a&gt;：分不同层次水平的Git学习教程&lt;/li&gt;
&lt;li&gt;&lt;a href="http://git-scm.com/book/en/Getting-Started"&gt;Git SCM Book&lt;/a&gt;：Git的介绍和比较详细文档&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Fork和clone代码库&lt;/h3&gt;
&lt;p&gt;“&lt;strong&gt;Fork&lt;/strong&gt;”是Github上将一个代码库复制到自己账户下的一个操作术语。采用该操作不仅可以保留原始代码库的信息，还能让你在这些代码库的基础上进行开发升级。“&lt;strong&gt;Clone&lt;/strong&gt;”是git中将一个代码库复制到你自己电脑上的操作术语。&lt;/p&gt;
&lt;p&gt;假如你不想在github上注册账号，你可以跳过下面的“Cloning”部分，否则的话，创建你的账户并登陆，开始&lt;strong&gt;forking&lt;/strong&gt;主代码库。&lt;/p&gt;
&lt;h4&gt;Forking主代码库&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;登陆Github并前往&lt;a href="https://github.com/diydrones/ardupilot"&gt;https://github.com/diydrones/ardupilot&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;“Fork”按键位于页面右上角：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img alt="Fork-position" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2014/04/APM-Git-Github-Fork.jpg" /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;点击Fork按钮即可。&lt;/p&gt;
&lt;h4&gt;Cloning主代码库&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;现在你需要克隆一份代码到你的本地电脑上。进入你要克隆的刚刚“Fork”的代码库或者直接在APM的主代码库，在屏幕的右侧，会发现你需要克隆代码库的相关按钮信息：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img alt="clone-button" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2014/04/APM-Git-Github-Clone.jpg" /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;克隆代码库到指定目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OSX/Linux终端：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone https://github.com/your_username/ardupilot&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows（Github用户界面）：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ａ、在你的web浏览器中打开&lt;a href="https://github.com/diydrones/ardupilot"&gt;diydrones/ardupilot 代码库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ｂ、点击右下角的“Clone in desktop”按钮&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img alt="clone-in-desktop" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/08/CloningTheRepository_Windows1-300x246.png" /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ｃ、 如果你之前还没有安装Github：&lt;/p&gt;
&lt;p&gt;１） 请到windows.github.com页面，按下右上角的“downlaod”按钮下载安装包&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img alt="download-windows-github" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/08/CloningTheRepository_Windows_DownloadGithub.png" /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;２） 在你的电脑上保存文件，然后运行并按说明安装Github客户端&lt;/p&gt;
&lt;p&gt;３） 在Github客户端界面上点击右侧箭头按钮来查看最近提交的内容列表，或者在
diydrones/ardupilot 代码库上右击选择“open in explorer”（在文件管理器中代开）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img alt="open-in-explorer" src="http://dev.ardupilot.com/wp-content/uploads/sites/6/2013/08/CloningTheRepository_Windows_OpenGithub.png" /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在，你可以用你最喜爱的编辑器,如NotePad++，subline Text或者acme中打开文件。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;链接&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dev.ardupilot.com/wiki/where-to-get-the-code/"&gt;APM官网原文链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html"&gt;APM开发人员参考手册目录列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;(over)&lt;/em&gt;&lt;/p&gt;</summary><category term="APM"></category><category term="飞控板"></category><category term="硬件"></category><category term="Git"></category></entry><entry><title>APM开发人员参考手册目录列表</title><link href="http://liung.github.io/blog/apm/2014-08-29-APM-%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C%E7%9B%AE%E5%BD%95%E5%88%97%E8%A1%A8.html" rel="alternate"></link><updated>2014-08-29T13:08:10+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-08-29:blog/apm/2014-08-29-APM-开发人员参考手册目录列表.html</id><summary type="html">

&lt;p&gt;从现在开始，我打算利用我空闲的时间，针对APM官网上的开发流程进行翻译，翻译不求精准，但求能准确传达要表达的意思即可，非专业译者，水平有限，敬请谅解。并且，还计划展开一系列的专题blog，对APM的源码进行解析，以了解APM自动飞控的工作原理（希望我的C++水平过关，可以理解源码的意思），由于涉及到了非常专业的单片机、飞行器控制、空气动力学原理、计算机编程、调试等非常专业的知识，所以难免出现一些错误，如有发现，希望通过邮箱与我指正。同时，真切希望国内也有如此爱好开源、爱好贡献的人们积极参与到诸如此类如此有趣的项目中来，让每个人从中受益。帮助别人的同时，也在丰富自己。 :&amp;gt;&lt;/p&gt;


&lt;p&gt;下文中的条目如果我已经翻译完成，那么我将链接到对应的博客目录中去，如果还没有翻译，那么将默认连接到原官网的链接,且用*标示出来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/table-of-contents/"&gt;英文目录&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="http://dev.ardupilot.cn/"&gt;介  绍&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;------&amp;gt; &lt;strong&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-29-APM-获取源码.html"&gt;获取代码&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------&amp;gt; &lt;strong&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-30-APM-Arducopter代码预览.html"&gt;ArduCopter源码预览&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-30-APM-Arducopter相关库介绍.html"&gt;代码库介绍&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://liung.github.io/blog/apm/2014-08-31-APM-ArduCopter姿态控制概览.html"&gt;姿态控制&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://liung.github.io/blog/apm/2014-09-02-APM-添加新的参数.html"&gt;添加新的参数&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://liung.github.io/blog/apm/2014-09-05-APM-ArduCopter添加新的飞行模式.html"&gt;添加新的飞行模式&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://liung.github.io/blog/apm/2014-09-05-APM-ArduCopter规划新代码使之按一定频率运行.html"&gt;规划新代码使之按一定频率运行&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://liung.github.io/blog/apm/2014-09-05-APM-增加新的MAVLink通讯协议消息.html"&gt;增加新的MAVLink通讯协议消息&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------&amp;gt; &lt;strong&gt;&lt;a href="http://liung.github.io/blog/apm/2014-09-06-APM-编译代码.html"&gt;编译代码&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://liung.github.io/blog/apm/2014-09-06-APM-Windows平台上用Arduino编译ArduPilot.html"&gt;Windows平台上用Arduino编译ArduPilot&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://liung.github.io/blog/apm/2014-09-07-APM-Windows平台上用Make方法编译Pixhawk和PX4.html"&gt;Windows平台上用Make方法编译Pixhawk/PX4&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://liung.github.io/blog/apm/2014-09-08-APM-MacOS平台上用Arduino编译APM2.x.html"&gt;MacOS平台上用Arduino编译APM2.x *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://liung.github.io/blog/apm/2014-09-08-APM-MacOS平台上用Make方法编译Pixhawk和PX4.html"&gt;MacOS平台上用Make方法编译Pixhawk/PX4 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="{{filename}2014-09-10-APM-Linux平台上用Make方法编译APM2.x"&gt;Linux平台上用Make方法编译APM2.x&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://liung.github.io/blog/apm/2014-09-10-APM-Linux平台上用Make方法编译Pixhawk和PX4.html"&gt;Linux平台上用Make方法编译Pixhawk/PX4&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/building_with_make/"&gt;采用Make方法编译APM2.x（Win，Mac，Linux） *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/building-with-eclipse/"&gt;使用Eclipse编译 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/building-ardupilot-apm-with-visual-studio-visual-micro/"&gt;使用Atmel Studio或者Visual Studio编译APM *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/buildin-mission-planner/"&gt;使用Visual Studio编译Mission Planner *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/building-for-beaglebone-black-on-linux/"&gt;Linux上针对BeagleBone Black的编译 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/building-apm-for-flymaple/"&gt;Linux上针对Flymaple的APM编译 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/load-the-code-onto-apm2x/"&gt;加载代码到APM2.x *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/editing-the-code/"&gt;编辑代码 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/editing-the-code-with-eclipse/"&gt;使用Eclipse编辑代码 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/building-ardupilot-apm-with-visual-studio-visual-micro/"&gt;使用Atmel Studio 或者 微软的Visual Studio编辑代码 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/git_github_guide/"&gt;Git和Github操作指南 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------&amp;gt; &lt;strong&gt;&lt;a href="http://liung.github.io/blog/apm/2014-10-14-APM-模拟仿真.html"&gt;模拟仿真&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://liung.github.io/blog/apm/2014-10-14-APM-Windows上SITL仿真设置.html"&gt;Windows上设置SITL（Sorftware In The Loop，软件循环仿真）&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://liung.github.io/blog/apm/2014-10-14-APM-Linux上SITL仿真设置.html"&gt;Linux上设置SITL（Sorftware In The Loop，软件循环仿真）&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://liung.github.io/blog/apm/2014-10-15-APM-回放功能测试.html"&gt;日志回放测试&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/debugging-with-gdb/"&gt;GDB调试 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/submitting-patches-back-to-master/"&gt;提交补丁（patches）到git仓库（master） *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/raspberry-pi-via-mavlink/"&gt;通过MAVLink协议和树莓派（Raspberry Pi）通信 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/odroid-via-mavlink/"&gt;通过MAVLink协议和Odroid通信 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------&amp;gt; &lt;strong&gt;&lt;a href="http://liung.github.io/blog/apm/2014-10-16-APM-Windows7上的MAVProxy使用.html"&gt;Windows7上的MAVProxy使用&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/apmpilot_project_developer_information/"&gt;APMPilot开发信息 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/guidelines-for-contributors-to-the-apm-codebase/"&gt;面向新开发人员向APM代码库添加代码的一些指导 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/interfacing-with-apm-using-the-debug-terminal/"&gt;用Debug终端盒APM交互 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/interfacing-with-pixhawk-using-the-nsh/"&gt;使用NSH和Pixhawk交互 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/mavlink-parameters/"&gt;MavLink参数集 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/mavlink-commands/"&gt;MavLink命令集 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/serial_output/"&gt;串行输出 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/i2c/"&gt;I2C *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/release-procedures/"&gt;代码发布流程 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/advanced-configuration-settings/"&gt;高级配置设置 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/updating-the-apm2-x-bootloade/"&gt;升级APM2.x的引导程序 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/gps_guide/"&gt;GPS指导 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/gps_input/"&gt;GPS输入 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/gps_input_raw/"&gt;GPS原始输入 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/combo_2/"&gt;组合方式2 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/combo_3/"&gt;组合方式3 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/combo_4/"&gt;组合方式4 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/common-editor-information-resource/"&gt;APM官网的网站编辑器信息资源 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/editor-notes/"&gt;编辑器须知 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/graphics-resource-page/"&gt;图片资源页面 *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/ez-developer-walk-throughs-for-windows/"&gt;EZ Developer Walk Throughs for Windows *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/ez-install-the-ardupilot-source-code-on-your-computer-using-zip/"&gt;EZ Install the ArduPilot Source Code on your Computer Using Zip *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/ez-get-arduino-and-initialize-it-to-work-with-ardupilot/"&gt;EZ Get Arduino and Initialize it to work with ArduPilot *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/ez-arduino-compile-and-upload-the-ardupilot-firmware-to-your-apm/"&gt;EZ Arduino Compile and Upload the ArduPilot Firmware to your APM *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/ez-building-apm2-with-make-in-windows/"&gt;EZ Building APM2 with Make in Windows *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/ez-using-eclipse-for-ardupilot-development-in-windows/"&gt;EZ Using Eclipse for ArduPilot Development in Windows *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;------------&amp;gt;&amp;gt; &lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/ez-set-up-and-build-ardupilot-for-px4-in-windows/"&gt;EZ Set up and Build ArduPilot for PX4 in Windows *&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="http://dev.ardupilot.com/wiki/git_tortise/"&gt;Git_Tortise的使用 *&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="APM"></category><category term="飞控板"></category><category term="硬件"></category></entry><entry><title>测试，这是我的第一个博客网站</title><link href="http://liung.github.io/blog/qi-ta/home.html" rel="alternate"></link><updated>2014-08-29T00:00:00+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-08-29:blog/qi-ta/home.html</id><summary type="html">&lt;p&gt;Category：Python
Tag: other&lt;/p&gt;
&lt;p&gt;这是用来测试的blog。第一次blog搭建过程。&lt;/p&gt;</summary></entry><entry><title>Pelican官方文档阅读笔记</title><link href="http://liung.github.io/blog/python/2014-08-27-Pelican%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.html" rel="alternate"></link><updated>2014-08-27T20:13:00+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2014-08-27:blog/python/2014-08-27-Pelican官方文档阅读笔记.html</id><summary type="html">&lt;hr /&gt;
&lt;h3&gt;Articles and pages&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;article：一种有时间顺序的文件，诸如博客中的推送，一般都带有明确的日期。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;page：一般来讲不是一些暂时性的东西，经常用来充当博客中长时间不会改变的内容（比如abot、contact页面等）。通过设置&lt;code&gt;DISPLAY_PAGES_ON_MENU&lt;/code&gt;设置是否要在主导航菜单显示page中的内容（默认为True），在标签中设置&lt;code&gt;status：hidden&lt;/code&gt;来隐藏page中特定的文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;File metadata（文章的元数据）&lt;/h3&gt;
&lt;p&gt;一般写的博客中包含一些&lt;code&gt;metadata&lt;/code&gt;数据。&lt;code&gt;makedown&lt;/code&gt;格式的书写方式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Title&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;My&lt;/span&gt; &lt;span class="kd"&gt;super&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;
&lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2010&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;03&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;
&lt;span class="n"&gt;Modified&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2010&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;05&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;
&lt;span class="n"&gt;Category&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Python&lt;/span&gt;
&lt;span class="n"&gt;Tags&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;pelican&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;publishing&lt;/span&gt;
&lt;span class="n"&gt;Slug&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;post&lt;/span&gt;
&lt;span class="n"&gt;Authors&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Alexis&lt;/span&gt; &lt;span class="n"&gt;Metaireau&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Conan&lt;/span&gt; &lt;span class="n"&gt;Doyle&lt;/span&gt;
&lt;span class="n"&gt;Summary&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Short&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;feeds&lt;/span&gt;

&lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="kd"&gt;super&lt;/span&gt; &lt;span class="n"&gt;blog&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;日期(Date)：如果文章中没有指定日期或者配置文件中没有设置DEFAULT_DATE = 'fs'，那么pelican将采用文件系统的     mtim时间，并根据文件所在位置的文件名进行分类（category）。&lt;/li&gt;
&lt;li&gt;分类：如果您你想用其他方式组织你的文章，可以在配置文件中设置&lt;code&gt;USE_FOLDER_AS_CATEGORY = False&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;authors:采用逗号分隔的作者列表，如果单作者，可以采用author标签。&lt;/li&gt;
&lt;li&gt;summary:配置文件中可以通过&lt;code&gt;SUMMARY_MAX_LENGTH&lt;/code&gt;设置summary长度。&lt;/li&gt;
&lt;li&gt;文件名：通过&lt;code&gt;FILENAME_METADATA&lt;/code&gt;设置，采用正则表达式。诸如&lt;code&gt;'(?P&amp;lt;date&amp;gt;\d{4}-\d{2}-\d{2})_(?P&amp;lt;slug&amp;gt;.*)'&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Linking to internal content（文件中的链接）&lt;/h3&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为向后兼容，也支持&lt;code&gt;|filename|path/to/file&lt;/code&gt;，（&lt;code&gt;{ }&lt;/code&gt;替换为&lt;code&gt;| |&lt;/code&gt;）但可能与reST、markdown等格式冲突，建议不用。&lt;/p&gt;
&lt;p&gt;设置静态文件（自动生成时将copy此文件到bolog目录）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;STATIC_PATHS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;images&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Syntax highlighting（语法高亮）&lt;/h3&gt;
&lt;p&gt;Markdown格式：&lt;/p&gt;
&lt;p&gt;A block of text.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;goes&lt;/span&gt; &lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以python为例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DemoClass&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;myFunction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Hello&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;identifier&lt;/code&gt;指定为&lt;code&gt;python&lt;/code&gt;、&lt;code&gt;ruby&lt;/code&gt;等语言即可。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;待补充......&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;参考阅读&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Pelican&lt;/strong&gt;&lt;a href="http://docs.getpelican.com/en/latest/"&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pelican&lt;/strong&gt;&lt;a href="http://pelican-docs-zh-cn.readthedocs.org/en/latest/"&gt;中文文档&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;</summary><category term="python"></category><category term="博客"></category></entry><entry><title>文件内的链接测试</title><link href="http://liung.github.io/blog/fei-xing-qi/article1.html" rel="alternate"></link><updated>2012-12-01T10:02:00+08:00</updated><author><name>liung</name></author><id>tag:liung.github.io,2012-12-01:blog/fei-xing-qi/article1.html</id><summary type="html">&lt;p&gt;See below intra-site link examples in Markdown format.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://liung.github.io/blog/qi-ta/home.html"&gt;a link relative to content root&lt;/a&gt;
&lt;a href="http://liung.github.io/blog/qi-ta/home.html"&gt;a link relative to current file&lt;/a&gt;&lt;/p&gt;</summary></entry></feed>